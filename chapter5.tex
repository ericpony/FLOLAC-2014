\chapter{Relational algebraic ornaments}
\label{chap:algebraic}

\todo[inline]{the synthetic direction of the conversion isomorphism; emphasis no longer only on program derivation (relational calculus) but also on relational specifications}

\section{Relational programming in Agda}
\label{sec:relations}

\todo[inline]{intro needs revision to de-emphasise program derivation a bit}

One common approach to program derivation is by algebraic transformations of functional programs: one begins with a specification in the form of a functional program that expresses straightforward but possibly inefficient computation, and transforms it into an extensionally equal but more efficient functional program by applying algebraic laws and theorems.
Using functional programs as the specification language means that specifications are directly executable, but the deterministic nature of functional programs can result in less flexible specifications.
For example, when specifying an optimisation problem using a functional program that generates all feasible solutions and chooses an optimal one among them, the program would enforce a particular way of choosing the optimal solution, but such enforcement should not be part of the specification.
To gain more flexibility, the specification language was later generalised to \emph{relational programs}.
With relational programs, we specify only the relationship between input and output without actually specifying a way to execute the programs, so specifications in the form of relational programs can be as flexible as possible.
Though lacking a directly executable semantics, most relational programs can still be read computationally as potentially partial and nondeterministic mappings, so relational specifications largely remain computationally intuitive as functional specifications.

To emphasise the computational interpretation of relations, we will mainly model a relation between sets |A|~and~|B| as a function sending each element of~|A| to a \emph{subset} of~|B|.
We define subsets by
\begin{code}
℘ : Set → Set₁
(Power A) = A → Set
\end{code}
That is, a subset |s : (Power A)| is a characteristic function that assigns a type to each element of~|A|, and |a : A| is considered to be a member of~|s| if the type |s a : Set| is inhabited.
We may regard |(Power A)| as the type of computations that nondeterministically produce an element of~|A|.
A simple example is
\begin{code}
any : {A : Set} → (Power A)
any = const ⊤
\end{code}
The subset |any : (Power A)| associates the unit type~|⊤| with every element of~|A|.
Since |⊤|~is inhabited, |any| can produce any element of~|A|.
While |℘|~cannot be made into a conventional monad~\citep{Moggi-monads, Wadler-essence} because it is not an endofunctor, it can still be equipped with the usual monadic programming combinators, giving rise to a \emph{relative monad}~\citep{Altenkirch-relative-monads}:
\begin{itemize}
\item The monadic unit is defined as
\begin{code}
return : {A : Set} → A → (Power A)
return = _≡_
\end{code}
The subset |return a : (Power A)| for some |a : A| simplifies to |(lambda(a')) a ≡ a'|, so |a|~is the only member of the subset.
\item The monadic bind is defined as
\begin{code}
_>>=_ : {A B : Set} → (Power A) → (A → (Power B)) → (Power B)
_>>=_ {A} s f = (lambda(b)) (Σ'(a ∶ A)) s a × f a b
\end{code}
If |s : (Power A)| and |f : A → (Power B)|, then the subset |s >>= f : (Power B)| is the disjoint union of all the subsets |f a : (Power B)| where |a|~ranges over the elements of~|A| that belong to~|s|; that is, an element |b : B| is a member of |s >>= f| exactly when there exists some |a : A| belonging to~|s| such that |b|~is a member of |f a|.
\end{itemize}
It is easy to show that the two combinators satisfy the (relative) monad laws up to pointwise isomorphism, whose proofs we omit from the presentation.
On top of |return| and |_>>=_|\kern1pt, the functorial map of~|℘| is defined as
\begin{code}
_<$> : {A B : Set} → (A → B) → (Power A) → (Power B)
f <$> s = s >>= (lambda(a)) return (f a)
\end{code}
and we also define a two-argument version for convenience:
\begin{code}
_<$>² : {A B C : Set} → (A → B → C) → (Power A) → (Power B) → (Power C)
f <$>² s t = s >>= (lambda(a)) t >>= (lambda(b)) return (f a b)
\end{code}
The notation is a reference to applicative functors~\citep{McBride-Applicative}, allowing us to think of functorial maps of~|℘| as applications of pure functions to effectful arguments.

We will mainly use families of relations between families of sets:
\begin{code}
_↝_ : {I : Set} → (I → Set) → (I → Set) → Set₁
X ↝ Y = ∀ {i} → X i → (Power (Y i))
\end{code}
which is the usual generalisation of~|_⇉_| to allow nondeterminacy.\todo{relations vs families of relations}\
Here we define several relational operators that we will need.
\begin{itemize}
\item Since functions are deterministic relations, we have the following combinator |fun| that lifts functions to relations using |return|.
\begin{code}
fun : {I : Set} {X Y : I → Set} → (X ⇉ Y) → (X ↝ Y)
fun f x = return (f x)
\end{code}
\item The identity relation is just the identity function lifted by |fun|.
\begin{code}
idR : {I : Set} {X : I → Set} → (X ↝ X)
idR = fun id
\end{code}
\item Composition of relations is easily defined with |_>>=_|\,: computing |R • S| on input~|x| is first computing |S x| and then feeding the result to~|R|.
\begin{code}
_•_ : {I : Set} {X Y Z : I → Set} → (Y ↝ Z) → (X ↝ Y) → (X ↝ Z)
(R • S) x = S x >>= R
\end{code}
\item Some relations do not carry obvious computational meaning, which we can still define pointwise, like the meet of two relations:
\begin{code}
_∩_ : {I : Set} {X Y : I → Set} → (X ↝ Y) → (X ↝ Y) → (X ↝ Y)
(R ∩ S) x y = R x y × S x y
\end{code}
\item Unlike a function, which distinguishes between input and output, inherently a relation treats its domain and codomain symmetrically.
This is reflected by the presence of the following \emph{converse} operator:
\begin{code}
_º : {I : Set} {X Y : I → Set} → (X ↝ Y) → (Y ↝ X)
(R º) y x = R x y
\end{code}
A relation can thus be ``run backwards'' simply by taking its converse.
The nondeterministic and bidirectional nature of relations makes them a powerful and concise language for specifications, as will be demonstrated in Sections \ref{sec:metamorphism-streaming}~and~\ref{sec:minimum-coin-change}.
\begin{figure}
\codefigure
\begin{code}
mapR :  {I : Set} (D : RDesc I) {X Y : I → Set} →
        (X ↝ Y) → ⟦ D ⟧ X → (Power(⟦ D ⟧ Y))
mapR (ṿ [])        R tt        =  return tt
mapR (ṿ (i ∷ is))  R (x , xs)  =  pair <$>² (R x) (mapR (ṿ is) R xs)
mapR (σ S D)       R (s , xs)  =  (pair s) <$> (mapR (D s) R xs)

Ṙ :  {I : Set} (D : Desc I) {X Y : I → Set} → (X ↝ Y) → (Ḟ D X ↝ Ḟ D Y)
Ṙ D R {i} = mapR (D i) R
\end{code}
\caption{Definition for relators.}
\label{fig:relators}
\end{figure}
\item We will also need \emph{relators}, i.e., functorial maps on relations:
\begin{code}
Ṙ :  {I : Set} (D : Desc I) {X Y : I → Set} →
     (X ↝ Y) → (Ḟ D X ↝ Ḟ D Y)
\end{code}
If |R : X ↝ Y|, the relation |Ṙ D R : Ḟ D X ↝ Ḟ D Y| applies~|R| to the recursive positions of its input, leaving everything else intact.
The definition of~|Ṙ| is shown in \autoref{fig:relators}.
For example, if |D = ListD A|, then |Ṙ (ListD A)| is, up to isomorphism,
\begin{code}
Ṙ (ListD A) :  {X Y : I → Set} →
               (X ↝ Y) → (Ḟ (ListD A) X ↝ Ḟ (ListD A) Y)
Ṙ (ListD A) R (`nil   ,          tt)  = return (`nil , tt)
Ṙ (ListD A) R (`cons  , a , x ,  tt)  = ((lambda(y)) `cons , a , y , tt) <$> (R x)
\end{code}
%Among other properties, we can prove that |Ṙ D| preserves identity (|Ṙ D idR ≃ idR|), composition (|Ṙ D (R • S) ≃ Ṙ D R • Ṙ D S|), converse (|Ṙ D (R º) ≃ (Ṙ D R) º|), and is monotonic (|R ⊆ S| implies |Ṙ D R ⊆ Ṙ D S|).
\end{itemize}

Laws and theorems about relational programs are formulated with relational inclusion:
\begin{code}
_⊆_ : {I : Set} {X Y : I → Set} (R S : X ↝ Y) → Set
R ⊆ S = ∀ {i} → (x : X i) (y : Y i) → R x y → S x y
\end{code}
or equivalence of relations, i.e., two-way inclusion:
\begin{code}
_≃_ : {I : Set} {X Y : I → Set} (R S : X ↝ Y) → Set
R ≃ S = (R ⊆ S) × (S ⊆ R)
\end{code}
With relational inclusion, many concepts can be expressed in a surprisingly concise way.
For example, a relation~|R| is a preorder if it is reflexive and transitive.
In relational terms, these two conditions are expressed simply as
\[ |idR ⊆ R| \qquad\text{and}\qquad |R • R ⊆ R| \]
and are easily manipulable in calculations.
Another important notion is \emph{monotonic algebras}~\cite[Section 7.2]{Bird-AoP}: an algebra |S : Ḟ D X ↝ X| is \emph{monotonic} on |R : X ↝ X| (usually an ordering) if
\begin{code}
S • Ṙ D R ⊆ R • S
\end{code}
which says that if two input values to~|S| have their recursive positions related by~|R| and are otherwise equal, then the output values would still be related by~|R|.
In the context of optimisation problems, monotonicity can be used to capture the \emph{principle of optimality}, as will be shown in \autoref{sec:minimum-coin-change}.

\todo[inline]{probably a simple example of relational calculation here?}

\begin{figure}
\codefigure
\begin{code}
mutual

  foldR :  {I : Set} {D : Desc I} {X : I → Set} → (Ḟ D X ↝ X) → (μ D ↝ X)
  foldR {I} {D} R {i} (con ds) = mapFoldR D (D i) R ds >>= R

  mapFoldR :  {I : Set} (D : Desc I) (D' : RDesc I) →
              {X : I → Set} → (Ḟ D X ↝ X) → ⟦ D' ⟧ (μ D) → (Power(⟦ D' ⟧ X))
  mapFoldR D (ṿ [])        R tt         = return tt
  mapFoldR D (ṿ (i ∷ is))  R (d  , ds)  = pair <$>²  ((cata(R)) d)
                                                     (mapFoldR D (ṿ is) f ds)
  mapFoldR D (σ S D')      R (s  , ds)  = (pair s) <$> (mapFoldR D (D' s) f ds)
\end{code}
\caption{Definition of relational folds.}
\label{fig:foldR}
\end{figure}

Having defined relations as nondeterministic mappings, it is straightforward to rewrite the datatype-generic |fold| with the subset combinators to obtain a relational version, which is denoted by ``banana brackets''~\citep{Meijer-bananas}:
\begin{code}
foldR :  {I : Set} {D : Desc I} {X : I → Set} → (Ḟ D X ↝ X) → (μ D ↝ X)
\end{code}
The definition of |foldR| is shown in \autoref{fig:foldR}.
For example, the relational fold on lists is, up to isomorphism,
\begin{code}
foldR {⊤} {ListD A} :  {X : ⊤ → Set} →
                       (Ḟ (ListD A) X ↝ X) → (μ (ListD A) ↝ X)
(cata(R)) []        =   R (`nil , tt)
(cata(R)) (a ∷ as)  =   (cata(R)) as >>= (lambda(x)) R (`cons , a , x , tt)
\end{code}
The functional and relational fold operators are related by the following lemma:
\begin{code}
fun-preserves-fold :  {I : Set} (D : Desc I) {X : I → Set} →
                      (f : Ḟ D X ⇉ X) {i : I} (d : μ D i) (x : X i) →
                      fun (fold f) d x ≅ (cata(fun f)) d x
\end{code}
which is a strengthened version of |fun (fold f) ≃ (cata(fun f))|.

\section{Definition of relational algebraic ornaments}
\label{sec:algOD}

We now turn to relational algebraic ornamentation, the key construct that bridges internalist and relational programming.
Let
\begin{code}
R : Ḟ (ListD A) (const X) ↝ const X
\end{code}
(where |X : Set|) be a relational algebra for lists.
We can define a datatype of ``algebraic lists'' as
\begin{code}
indexfirst data AlgList A R : X → Set where
  AlgList A R x  offers  nil (rnil : R (`nil , tt) x)
                 or      cons  (a : A) (x' : X)
                               (rcons : R (`cons , a , x' , tt) x)
                               (as : AlgList A R x')
\end{code}
There is an ornament from lists to algebraic lists which marks the fields |rnil|, |x'|, and |rcons| in |AlgList| as additional and refines the index of the recursive position from~|tt| to~|x'|.
The optimised predicate~(\autoref{sec:optimised-predicates}) for this ornament is
\begin{code}
indexfirst data AlgListP A R : X → List A → Set where
  AlgListP A R x []        offers  nil (rnil : R (`nil , tt) x)
  AlgListP A R x (a ∷ as)  offers  cons  (x' : X)
                                         (rcons : R (`cons , a , x' , tt) x)
                                         (p : AlgListP A R x' as)
\end{code}
A simple argument by induction shows that |AlgListP A R x as| is in fact isomorphic to |(cata(R)) as x| for any |as : List A| and |x : X|.
By predicate swapping for the refinement semantics of the ornament from lists to algebraic lists (\autoref{sec:refinement-semantics}), we get
\begin{flalign}
&\hskip\mathindent |AlgList A R x ≅ (Σ'(as ∶ List A)) (cata(R)) as x| &
\label{eq:AlgList}
\end{flalign}
for all |x : X|.
That is, an algebraic list is exactly a plain list and a proof that the list folds to~|x| using the algebra~|R|.
The traditional bottom-up vector datatype is a special case of |AlgList| --- define
\begin{code}
length-alg :  Ḟ (ListD A) (const Nat) ⇉ const Nat
length-alg (`nil   ,          tt)  = zero
length-alg (`cons  , a , n ,  tt)  = suc n
\end{code}
and then |AlgList A (fun length-alg)| is exactly |Vec' A|.
By~(\ref{eq:AlgList}) we have the isomorphisms
\begin{code}
Vec' A n ≅ (Σ'(as ∶ List A)) (cata(fun length-alg)) as n
\end{code}
for all |n : Nat|, from which we can derive
\begin{code}
Vec' A n ≅ (Σ'(as ∶ List A)) length as ≡ n
\end{code}
by |fun-preserves-fold|, where |length = fold length-alg|.

\begin{figure}
\codefigure
\begin{code}
algROD :  {I : Set} (D : RDesc I) {J : I → Set} →
          (⟦ D ⟧ J → Set) → ROrnDesc (Σ I J) proj₁ D
algROD (ṿ is)   {J}     P =  (Δ'(js ∶ Ṗ is J)) (Δ'(_ ∶ P js))
                               ṿ (Ṗ-map ((lambda({i} j)) ok (i , j)) is js)
algROD (σ S D)  {-""-}  P =  (σ'(s ∶ S)) algROD (D s) (curry P s)

algOD :  {I : Set} (D : Desc I) {J : I → Set} →
         (Ḟ D J ↝ J) → OrnDesc (Σ I J) proj₁ D
algOD D R (ok (i , j)) = algROD (D i) ((lambda(js)) R js j)
\end{code}
\caption{Definitions for algebraic ornamentation.}
\label{fig:algOD}
\end{figure}

The above can be generalised to all datatypes encoded by the |Desc| universe.
Let |D : Desc I| be a description and |R : Ḟ D X ↝ X| (where |X : I → Set|) an algebra.
The \emph{algebraic ornamentation} of~|D| with~|R| is an ornamental description
\begin{code}
algOD D R : OrnDesc (Σ I X) proj₁ D
\end{code}
(where |proj₁ : Σ I X → I|).
The optimised predicate for |⌈ algOD D R ⌉| is pointwise isomorphic to |(cata(R))|, i.e.,
\begin{code}
OptP ⌈ algOD D R ⌉ (ok (i , x)) d ≅ (cata(R)) d x
\end{code}
for all |i : I|, |x : X i|, and |d : μ D i|.
These isomorphisms give rise to a family of predicate swaps for the refinement semantics of |⌈ algOD D R ⌉|, so we arrive at the following conversion isomorphisms
\begin{flalign}
&\hskip\mathindent |μ ⌊ algOD D R ⌋ (i , x) ≅ (Σ'(d ∶ μ D i)) (cata(R)) d x| &
\label{eq:algOD}
\end{flalign}
for all |i : I| and |x : X i|.
The definition of |algOD|, shown in \autoref{fig:algOD}, is an adaptation and generalisation of \varcitet{McBride-ornaments}{'s original definition of functional algebraic ornaments}.
Roughly speaking, it retains all the fields of the base description and inserts before every~|ṿ|
\begin{itemize}
\item a new field of indices for the recursive positions (e.g., the field~|x'| in |AlgList|) and
\item another new field requesting a proof that
\begin{itemize}
\item the indices supplied in the previous field and 
\item the values for the fields originally in the base description
\end{itemize}
computes to the targeted index through~|R| (e.g., the fields |rnil| and |rcons| in |AlgList|).
\end{itemize}

\todo[inline]{summary and some gluing to the next section}

%Algebraic ornamentation is a very convenient method for adding new indices to inductive families, and most importantly, it says precisely what the new indices mean.
%The method was demonstrated by \citet{McBride-ornaments} with a correct-by-construction compiler for a small language, and will be demonstrated again in \autoref{sec:minimum-coin-change}.

\section{Examples}

\subsection{The Fold Fusion Theorem}

As a first example of bridging internalist programming with relational calculation through algebraic ornamentation, let us consider the \emph{Fold Fusion Theorem}~\cite[Section~6.2]{Bird-AoP}:
Let |D : Desc I| be a description, |R : X ↝ Y| a relation, and |S : Ḟ D X ↝ X| and |T : Ḟ D Y ↝ Y| algebras.
If |R|~is a homomorphism from |S| to~|T|, i.e.,
\begin{code}
R • S ≃ T • Ṙ D R
\end{code}
which is referred to as the \emph{fusion condition}, then we have
\begin{code}
R • (cata(S)) ≃ (cata(T))
\end{code}
The above is, in fact, a corollary of two variations of Fold Fusion that replace relational equivalence in the statement of the theorem with relational inclusion.
One of the variations is
\begin{code}
R • S ⊆ T • Ṙ D R {-"\quad"-}→{-"\quad"-} R • (cata(S)) ⊆ (cata(T))
\end{code}
This can be used with~(\ref{eq:algOD}) to derive a conversion between algebraically ornamented datatypes:
\begin{code}
algOD-fusion-⊆ D R S T :
  R • S ⊆ T • Ṙ D R →
  {i : I} (x : X i) → μ ⌊ algOD D S ⌋ (i , x) →
  (y : Y i) → R x y → μ ⌊ algOD D T ⌋ (i , y)
\end{code}
The other variation of Fold Fusion simply reverses the direction of inclusion:
\begin{code}
R • S ⊇ T • Ṙ D R {-"\quad"-}→{-"\quad"-} R • (cata(S)) ⊇ (cata(T))
\end{code}
which translates to the conversion
\begin{code}
algOD-fusion-⊇ D R S T :
  R • S ⊇ T • Ṙ D R →
  {i : I} (y : Y i) → μ ⌊ algOD D T ⌋ (i , y) →
  (Σ'(x ∶ X i)) μ ⌊ algOD D S ⌋ (i , x) × R x y
\end{code}
For a simple example, suppose that we need a ``bounded'' vector datatype, i.e., lists indexed with an upper bound on their length.
A quick thought might lead to this definition
\begin{code}
BVec : Set → Nat → Set
BVec A m = μ ⌊ algOD (ListD A) (geq • fun length-alg) ⌋ (tt , m)
\end{code}
where |geq = λ x y → x ≤ y : const Nat ↝ const Nat| maps a natural number~|x| to any natural number that is at least~|x|.
The isomorphisms~(\ref{eq:algOD}) specialise for |BVec| to
\begin{code}
BVec A m ≅ (Σ'(as ∶ List A)) (cata(geq • fun length-alg)) as m
\end{code}
for all |m : Nat|.
But is |BVec| really the bounded vectors?
Indeed it is, because we can deduce
\begin{code}
geq • (cata(fun length-alg)) ≃ (cata(geq • fun length-alg))
\end{code}
by Fold Fusion.
The fusion condition is
\begin{code}
geq • fun length-alg ≃ geq • fun length-alg • Ṙ (ListD A) geq
\end{code}
The left-to-right inclusion is easily calculated as follows:\todo{relator laws and various monotonicity need to be stated earlier}
\begin{flalign*}
\hskip\mathindent & |geq • fun length-alg| & \\
\hskip\mathindent \subseteq~& \reason{|idR| identity} & \\
\hskip\mathindent & |geq • fun length-alg • idR| & \\
\hskip\mathindent \subseteq~& \reason{relator preserves identity} & \\
\hskip\mathindent & |geq • fun length-alg • Ṙ (ListD A) idR| & \\
\hskip\mathindent \subseteq~& \reason{|geq| reflexive} & \\
\hskip\mathindent & |geq • fun length-alg • Ṙ (ListD A) geq| &
\end{flalign*}
And from right to left:
\begin{flalign*}
\hskip\mathindent & |geq • fun length-alg • Ṙ (ListD A) geq| & \\
\hskip\mathindent \subseteq~& \reason{|fun length-alg| monotonic on |geq|} & \\
\hskip\mathindent & |geq • geq • fun length-alg| & \\
\hskip\mathindent \subseteq~& \reason{|geq| transitive} & \\
\hskip\mathindent & |geq • fun length-alg| &
\end{flalign*}
Note that these calculations are good illustrations of the power of relational calculation despite their simplicity --- they are straightforward symbolic manipulations, hiding details like quantifier reasoning behind the scenes.
As demonstrated by the AoPA library~\citep{Mu-AoPA}, they can be faithfully formalised with preorder reasoning combinators in Agda and used to discharge the fusion conditions of |algOD-fusion-⊆| and |algOD-fusion-⊇|.
Hence we get two conversions, one of type
\begin{code}
Vec A n → (n ≤ m) → BVec A m
\end{code}
which relaxes a vector of length~|n| to a bounded vector whose length is bounded above by some~|m| that is at least~|n|, and the other of type
\begin{code}
BVec A m → (Σ'(n ∶ Nat)) Vec A n × (n ≤ m)
\end{code}
which converts a bounded vector whose length is at most~|m| to a vector of length precisely~|n| and guarantees that |n|~is at most~|m|.

\todo[inline]{Just constraint transformation; base data do not change}

\subsection{The Streaming Theorem for list metamorphisms}
\label{sec:metamorphism-streaming}

A \emph{metamorphism}~\citep{Gibbons-metamorphisms} is an unfold after a fold --- it consumes a data structure to compute an intermediate value and then produces a new data structure using the intermediate value as the seed.
In this section we will restrict ourselves to metamorphisms consuming and producing lists.
As \citeauthor{Gibbons-metamorphisms} noted, (list) metamorphisms in general cannot be automatically optimised in terms of time and space, but under certain conditions it is possible to refine a list metamorphism to a \emph{streaming algorithm} --- which can produce an initial segment of the output list without consuming all of the input list --- or a parallel algorithm~\citep{Nakano-jigsaw}.
In the rest of this section, we prove the \emph{Streaming Theorem}~\citep[Theorem~30]{Bird-arithmetic-coding} by implementing the streaming algorithm given by the theorem with algebraic ornamented lists such that the algorithm satisfies its metamorphic specification by construction.

Our first step is to formulate a metamorphism as a relational specification of the streaming algorithm.
\begin{itemize}
\item The fold part needs a twist since using the conventional fold --- known as the \emph{right fold} for lists since the direction of computation on a list is from right to left (cf.~wind direction) --- does not easily give rise to a streaming algorithm.
This is because we wish to talk about ``partial consumption'' naturally: for a list, partial consumption means examining and removing some elements of the list to get a sub-list on which we can resume consumption, and the natural way to do this is to consume the list from the left, examining and removing head elements and keeping the tail.
We should thus use the \emph{left fold} instead, which is usually defined as
\begin{code}
foldl : {A X : Set} → (X → A → X) → X → List A → X
foldl f x []        = x
foldl f x (a ∷ as)  = foldl f (f x a) as
\end{code}
The connection to the conventional fold (and thus algebraic ornamentation) is not lost, however --- it is well known that a left fold can be alternatively implemented as a right fold by turning a list into a chain of functions of type |X → X| transforming the initial value to the final result:
\begin{code}
foldl-alg :  {A X : Set} → (X → A → X) →
             Ḟ (ListD A) (const (X → X)) ⇉ const (X → X)
foldl-alg f (`nil   ,          tt) = id
foldl-alg f (`cons  , a , h ,  tt) = h ∘ flip f a

foldl : {A X : Set} → (X → A → X) → X → List A → X
foldl f x as = fold (foldl-alg f) as x
\end{code}
The left fold can thus be linked to the relational fold by
\begin{flalign}
&\hskip\mathindent |fun (foldl f x) ≃ fun ((lambda(h)) h x) • (cata(fun (foldl-alg f)))| &
\label{eq:foldl}
\end{flalign}
\item The unfold part is approximated by the converse of a relational fold: given a list coalgebra |g : const X ⇉ Ḟ (ListD B) (const X)| for some |X : Set|, we take its converse, turning it into a relational algebra, and use the converse of the relational fold with this algebra.
\begin{code}
(cata(fun g º)) º : const X ↝ const (List A)
\end{code}
This is only an approximation because, while the relation does produce a list, the resulting list is inductive rather than coinductive, so the relation is actually a \emph{well-founded} unfold, which is incapable of producing an infinite list.
\end{itemize}
Thus, given a ``left algebra'' for consuming |List A|
\begin{code}
f : X → A → X
\end{code}
and a coalgebra for producing |List B|
\begin{code}
g : const X ⇉ Ḟ (ListD B) (const X)
\end{code}
which together satisfy a \emph{streaming condition} that we will see later, the streaming algorithm we implement, which takes as input the initial value |x : X| for the left fold, should be included in the following metamorphic relation:
\begin{code}
meta f g x = (cata(fun g º)) º • fun (foldl f x) : const (List A) ↝ const (List B)
\end{code}

Next we devise a type for the streaming algorithm that fully guarantees its correctness.
 By~(\ref{eq:foldl}), the specification |meta f g x| is equivalent to
\begin{code}
(cata(fun g º)) º • fun ((lambda(h)) h x) • (cata(fun (foldl-alg f)))
\end{code}
Inspecting the above relation, we see that a conforming program takes a |List A| that folds to some |h : X → X| with |fun (foldl-alg f)| and computes a |List B| that folds to |h x : X| with |fun g º|.
We are thus going to implement the streaming algorithm as
\begin{code}
stream f g :  (x : X) {h : X → X} →
              AlgList A (fun (foldl-alg f)) h → AlgList B (fun g º) (h x)
\end{code}
from which we can extract
\begin{code}
stream' f g : X → List A → List B
\end{code}
which is guaranteed to satisfy
\begin{code}
fun (stream' f g x)  ⊆ meta f g x
\end{code}
The extraction of |stream' f g| from |stream f g| is done with the help of the conversion isomorphisms~(\ref{eq:algOD}) for the two algebraic list datatypes involved:
\begin{code}
consumption-iso :
  (h : X → X) →
  AlgList A (fun (foldl-alg f)) h ≅ (Σ'(as ∶ List A)) fold (foldl-alg f) as ≡ h

production-iso :
  (x : X) → AlgList B (fun g º) x ≅ (Σ'(bs ∶ List B)) (cata(fun g º)) bs x
\end{code}
(where |consumption-iso| has been simplified by |fun-preserves-fold|).
Given |x : X|, what |stream' f g x| does is
\begin{itemize}
\item lifting the input |as : List A| to an algebraic list of type
\begin{code}
AlgList A (fun (foldl-alg f)) (fold (foldl-alg f) as)
\end{code}
using the right-to-left direction of |consumption-iso (fold (foldl-alg f) as)| (with the equality proof obligation discharged trivially by~|refl|),
\item transforming this algebraic list to a new one of type
\begin{code}
AlgList B (fun g º) (foldl f x as)
\end{code}
using |stream f g x|, and
\item demoting the new algebraic list to |List B| using the left-to-right direction of |production-iso (foldl f x as)|.
\end{itemize}
The use of |production-iso| in the last step ensures that the result |stream' f g x as : List B| satisfies
\begin{code}
(cata(fun g º)) (stream' f g x as) (foldl f x as)
\end{code}
which easily implies
\begin{code}
((cata(fun g º)) º • fun (foldl f x)) as (stream' f g x as)
\end{code}
i.e., |fun (stream' f g x) ⊆ meta f g x|, as required.

What is left is the implementation of |stream f g|.
Operationally, we maintain a state of type~|X| (and hence requires an initial state as an input to the function), and we can try either
\begin{itemize}
\item to update the state by consuming elements of~|A| with~|f|, or
\item to produce elements of~|B| (and transit to a new state) by applying~|g| to the state.
\end{itemize}
Since we want |stream f g| to be as productive as possible, we should always try to produce elements of~|B| with~|g| first, and only try to consume elements of~|A| with~|f| when |g|~produces nothing.
In Agda:
\begin{code}
stream f g :  (x : X) {h : X → X} →
              AlgList A (fun (foldl-alg f)) h → AlgList B (fun g º) (h x)
stream f g x      as                      with g x      | inspect g x
stream f g x {h}  as                      | next' b x'  | [ gxeq ] =  cons b (h x') (goal()(0))
                                                                        (stream f g x' as)
stream f g x      (nil        refl     )  | nothing     | [ gxeq ] =  nil gxeq
stream f g x      (cons a h'  refl as  )  | nothing     | [ gxeq ] =  stream f g (f x a) as
\end{code}
We match~|g x| with either of the two patterns |next' b x' = (`cons , b , x' , tt)| and |nothing = (`nil , tt)|.\todo{Agda doesn't really allow this, though.}
\begin{itemize}
\item If the result is |next' b x'|, we should emit~|b| and and use |x'| as the new state; the recursively computed algebraic list is indexed with~|h x'|, and we are left with a proof obligation of type |g (h x) ≡ next' b (h x')| at Goal~0; we will come back to this proof obligation later.
\item If the result is |nothing|, we should attempt to consume the input list.
\begin{itemize}
\item If the input list is empty, implying that the index~|h| of its type is just~|id|, both production and consumption have ended, so we return an empty list; the |nil| constructor requires a proof of |(fun g º) nothing (h x)|, which reduces to |g x ≡ nothing| and is discharged with the help of the ``inspect idiom'' in Agda's standard library (which, in a |with|-matching, gives a proof that the term being matched (in this case |g x|) is propositionally equal to the matched pattern (in this case |nothing|)).
\item Otherwise the input list is nonempty, implying that |h|~is |h' ∘ flip f a| where |a|~is the head of the input list, and we should continue with the new state |f x a|, keeping the tail for further consumption.
Typing directly works out because the index of the recursive result |h' (f x a)| and the required index |(h' ∘ flip f a) x| are definitionally equal.
\end{itemize}
\end{itemize}

\begin{figure}
\[ \begin{tikzpicture}[x=10em,y=4em]
\node(x) {|x|};
\node(x') [right=1 of x] {|x|\rlap{\smash{$^\prime$}}};
\node(hx) [below=1 of x] {|h x|};
\node(hx') [below=1 of x'] {|h x|\rlap{\smash{$^\prime$}}};
\draw[serif cm-to] (x) edge node[left]{consume~|as| with~|h|} (hx);
\draw[serif cm-to] (x') edge node[right]{consume~|as| with~|h|} (hx');
\draw[serif cm-to] (x) edge node[above]{produce~|b| with~|g|} (x');
\draw[serif cm-to] (hx) edge node[below]{produce~|b| with~|g|} (hx');
\end{tikzpicture} \]
\caption{State transitions involved in commutativity of production and consumption (cf.~\citet[Figures 1~and~2]{Gibbons-metamorphisms}).}
\label{fig:production-consumption-commutativity}
\end{figure}

Now we look at Goal~0.
We have
\begin{code}
gxeq : g x ≡ next' b x'
\end{code}
in the context, and need to prove
\begin{code}
g (h x) ≡ next' b (h x')
\end{code}
This is commutativity of production and consumption (see \autoref{fig:production-consumption-commutativity}):
The function |h : X → X| is the state transformation resulting from consumption of the input list~|as|.
From the initial state~|x|, we can either
\begin{itemize}
\item apply~|g| to~|x| to \emph{produce}~|b| and reach a new state~|x'|, and then apply~|h| to \emph{consume} the list and update the state to~|h x'|, or
\item apply~|h| to \emph{consume} the list and update the state to~|h x|, and then apply~|g| to~|h x| to \emph{produce} an element and reach a new state,
\end{itemize}
and we need to prove that the outcomes are the same: doing production using~|g| and consumption using~|h| in whichever order should emit the same element and reach the same final state.
This cannot be true in general, so we should impose some commutativity condition on |f|~and~|g|, which is called the \emph{streaming condition}:
\begin{code}
StreamingCondition f g : Set
StreamingCondition f g =
  (a : A) (b : B) (x x' : X) → g x ≡ next' b x' → g (f x a) ≡ next' b (f x' a)
\end{code}
The streaming condition is commutativity of one step of production and consumption, whereas the proof obligation at Goal~0 is commutativity of one step of production and multiple steps of consumption (of the entire list), so we perform a straightforward induction to extend the streaming condition along the axis of consumption:
\begin{code}
streaming-lemma :
  (b : B) (x x' : X) → g x ≡ next' b x' →
  {h : X → X} → AlgList A (fun (foldl-alg f)) h → g (h x) ≡ next' b (h x')
streaming-lemma b x x' eq (nil       refl     ) = eq
streaming-lemma b x x' eq (cons a h  refl as  ) =
  streaming-lemma b (f x a) (f x' a) (streaming-condition f g a b x x' eq) as
\end{code}
where |streaming-condition : StreamingCondition f g| is a proof term that should be supplied along with |f|~and~|g| in the beginning.
Goal~0 is then discharged by the term |streaming-lemma b x x' gxeq as|.

We have thus completed the implementation of the Streaming Theorem, except that |stream f g| is non-terminating, as there is no guarantee that |g|~produces only a finite number of elements.
In our setting, where the output list is specified to be finite, we can additionally require that |g|~is well-founded and revise |stream| accordingly (see, e.g., \citet{Nordstrom-accessibility}); the general way out is to switch to coinductive datatypes to allow the output list to be infinite, which, however, falls outside the scope of this thesis.

It is interesting to compare our implementation with the proofs of \citet{Bird-arithmetic-coding}.
While their Lemma~29 turns explicitly into our |streaming-lemma|, their Theorem~30 goes implicitly into the typing of |stream| and no longer needs special attention.
The structure of |stream| already matches that of \citeauthor{Bird-arithmetic-coding}'s proof of their Theorem~30, and the principled type design using algebraic ornamentation elegantly loads the proof onto the structure of |stream| --- this is internalism at its best.

\subsection{The minimum coin change problem}
\label{sec:minimum-coin-change}

Suppose that we have an unlimited number of 1-penny, 2-pence, and 5-pence coins, modelled by the following datatype:
\begin{code}
data Coin : Set where onep twop fivep : Coin
\end{code}
Given |n : Nat|, the \emph{minimum coin change problem} asks for the least number of coins that make up |n|~pence.
We can give a relational specification of the problem with the following minimisation operator:
\begin{code}
min_•Λ_ : {I : Set} {-"\kern-1pt"-} {X Y : I → Set} {-"\kern-1pt"-} (R : Y ↝ Y) {-"\kern-1pt"-} (S : X ↝ Y) → (X ↝ Y)
(min R •Λ S) x y = S x y × (∀ y' → S x y' → R y' y)
\end{code}
An input |x : X i| for some |i : I| is mapped by |min R •Λ S| to |y : Y i| if |y|~is a possible result in |S x : (Power (Y i))| and is the smallest such result under~|R|, in the sense that any~|y'| in~|S x : (Power (Y i))| must satisfy |R y' y|.
(We think of~|R| as mapping larger inputs to smaller outputs.)
Intuitively, we can think of |min R •Λ S| as consisting of two steps: the first step |Λ S| computes the set of all possible results yielded by~|S|, and the second step |min R| nondeterministically chooses a minimum result from that set.
We use bags of coins as the type of solutions, and represent them as decreasingly ordered lists indexed with an upper bound.
(This is a deliberate choice to make the derivation work, but one would naturally turn to this representation having attempted to apply the \emph{Greedy Theorem}, which will be introduced shortly.)
If we define the ordering on coins as
\begin{code}
_≤C_ : Coin → Coin → Set
c ≤C d = value c ≤ value d
\end{code}
where the values of the coins are defined by
\begin{code}
value : Coin → Nat
value  onep   =  1
value  twop   =  2
value  fivep  =  5
\end{code}
then the datatype of coin bags we use is
\begin{code}
CoinBagOD : OrnDesc Coin ! (ListD Coin)
CoinBagOD = OrdListOD Coin (flip _≤C_)

indexfirst data CoinBag : Coin → Set where
  CoinBag c  offers  nil
             or      cons  (d : Coin) (leq : d ≤C c) (b : CoinBag d)
\end{code}
The base functor for |CoinBag| is
\begin{code}
Ḟ ⌊ CoinBagOD ⌋ : (Coin → Set) → (Coin → Set)
Ḟ ⌊ CoinBagOD ⌋ X c =
  Σ ListTag λ  case  `nil   mapsto ⊤
               sep   `cons  mapsto (Σ'(d ∶ Coin)) (d ≤C c) × X d × ⊤ endcase
\end{code}
The total value of a coin bag is the sum of the values of the coins in the bag, which is computed by a (functional) fold:
\begin{code}
total-value-alg : Ḟ ⌊ CoinBagOD ⌋ (const Nat) ⇉ const Nat
total-value-alg (`nil   ,              tt) = 0
total-value-alg (`cons  , d , _ , n ,  tt) = value d + n

total-value : CoinBag ⇉ const Nat
total-value = fold total-value-alg
\end{code}
and the number of coins in a coin bag is also computed by a fold:
\begin{code}
size-alg : Ḟ ⌊ CoinBagOD ⌋ (const Nat) ⇉ const Nat
size-alg (`nil   ,              tt) = 0
size-alg (`cons  , _ , _ , n ,  tt) = 1 + n

size : CoinBag ⇉ const Nat
size = fold size-alg
\end{code}
The specification of the minimum coin change problem can now be written as
\begin{code}
min-coin-change : const Nat ↝ CoinBag
min-coin-change = min (fun size º • leq • fun size) •Λ (fun total-value º)
\end{code}
where |leq = geq º : const Nat ↝ const Nat| maps a natural number~|n| to any natural number that is at most~|n|.
Intuitively, given an input |n : Nat|, the relation |fun total-value º| computes an arbitrary coin bag whose total value is~|n|, so |min-coin-change| first computes the set of all such coin bags and then chooses from the set a coin bag whose size is smallest.
Our goal, then, is to write a functional program |f : const Nat ⇉ CoinBag| such that |fun f ⊆ min-coin-change|, and then |f {fivep} : Nat → CoinBag fivep| would be a solution.
(The type |CoinBag fivep| contains all coin bags, since |fivep| is the largest denomination and hence a trivial upper bound on the content of bags.)
Of course, we may guess what |f|~should look like, but its correctness proof is much harder.
Can we construct the program and its correctness proof in a more manageable way?

\subsubsection{The plan}

In traditional relational program derivation, we would attempt to refine the specification |min-coin-change| to some simpler relational program and then to an executable functional program by applying algebraic laws and theorems.
With algebraic ornamentation, however, there is a new possibility: if we can derive that, for some algebra |R : Ḟ ⌊ CoinBagOD ⌋ (const Nat) ↝ const Nat|,
\begin{flalign}
&\hskip\mathindent |(cata(R)) º ⊆ min-coin-change| &
\label{eq:generic-inclusion}
\end{flalign}
then we can manufacture a new datatype
\begin{code}
GreedyBagOD : OrnDesc (Coin × Nat) proj₁ ⌊ CoinBagOD ⌋
GreedyBagOD = algOD ⌊ CoinBagOD ⌋ R

GreedyBag : Coin → Nat → Set
GreedyBag c n = μ ⌊ GreedyBagOD ⌋ (c , n)
\end{code}
and construct a function of type
\begin{code}
greedy : (c : Coin) (n : Nat) → GreedyBag c n
\end{code}
from which we can assemble a solution
\begin{code}
sol : Nat → CoinBag fivep
sol = forget ⌈ GreedyBagOD ⌉ ∘ greedy fivep
\end{code}
The program~|sol| satisfies the specification because of the following argument:
For any |c : Coin| and |n : Nat|, by~(\ref{eq:algOD}) we have
\begin{code}
GreedyBag c n ≅ (Σ'(b ∶ CoinBag c)) (cata(R)) b n
\end{code}
In particular, since the first half of the left-to-right direction of the isomorphism is |forget ⌈ GreedyBagOD ⌉|, we have
\begin{code}
(cata(R)) (forget ⌈ GreedyBagOD ⌉ g) n
\end{code}
for any |g : GreedyBag c n|.
Substituting~|g| by |greedy fivep n|, we get
\begin{code}
(cata(R)) (sol n) n
\end{code}
which implies, by (\ref{eq:generic-inclusion}),
\begin{code}
min-coin-change n (sol n)
\end{code}
i.e., |sol|~satisfies the specification.
Thus all we need to do to solve the minimum coin change problem is
\begin{itemize}
\item refine the specification |min-coin-change| to the converse of a fold, i.e., find the algebra~|R| in~(\ref{eq:generic-inclusion}), and
\item construct the internalist program |greedy|.
\end{itemize}

\subsubsection{Refining the specification}

The key to refining |min-coin-change| to the converse of a fold lies in the following version of the \emph{Greedy Theorem}, which is essentially a specialisation of \varcitet{Bird-AoP}{'s Theorem~10.1}:
Let |D : Desc I| be a description, |R : μ D ↝ μ D| a preorder, and |S : Ḟ D X ↝ X| an algebra.
Consider the specification
\begin{code}
min R •Λ ((cata(S)) º)
\end{code}
That is, given an input value |x : X i| for some |i : I|, we choose a minimum under~|R| among all those elements of |μ D i| that computes to~|x| through~|(cata(S))|.
The Greedy Theorem states that, if the initial algebra
\begin{code}
α = fun con : Ḟ D (μ D) ↝ μ D
\end{code}
is monotonic on~|R|, i.e.,
\begin{code}
α • Ṙ D R ⊆ R • α
\end{code}
and there is a relation (ordering) |Q : Ḟ D X ↝ Ḟ D X| such that the \emph{greedy condition}
\begin{code}
α • Ṙ D ((cata(S)) º) • (Q ∩ (S º • S)) º ⊆ R º • α • Ṙ D ((cata(S)) º)
\end{code}
is satisfied, then we have
\begin{code}
(cata((min Q •Λ (S º)) º)) º ⊆ min R •Λ ((cata(S)) º)
\end{code}
Here we offer an intuitive explanation of the Greedy Theorem, but the theorem admits an elegant calculational proof, which can be faithfully reprised in Agda.
The monotonicity condition states that if |ds : Ḟ D (μ D) i| for some |i : I| is better than |ds' : Ḟ D (μ D) i| under |Ṙ D R|, i.e., |ds|~and~|ds'| are equal except that the recursive positions of~|ds| are all better than the corresponding recursive positions of~|ds'| under~|R|, then |con ds : μ D i| would be better than |con ds' : μ D i| under~|R|.
This implies that, when solving the optimisation problem, better solutions to subproblems would lead to a better solution to the original problem, so the \emph{principle of optimality} applies --- to reach an optimal solution, it suffices to find optimal solutions to subproblems, and we are entitled to use the converse of a fold to find optimal solutions recursively.
The greedy condition further states that there is an ordering~|Q| on the ways of decomposing the problem which has significant influence on the quality of solutions:
Suppose that there are two decompositions |xs| and |xs' : Ḟ D X i| of some problem |x : X i| for some |i : I|, i.e., both |xs|~and~|xs'| are in |S º x : (Power (Ḟ D X i))|, and assume that |xs|~is better than~|xs'| under~|Q|.
Then for any solution resulting from~|xs'| (computed by |α • Ṙ D ((cata(S)) º)|) there always exists a better solution resulting from~|xs|, so ignoring~|xs'| would only rule out worse solutions.
The greedy condition thus guarantees that we will arrive at an optimal solution by always choosing the best decomposition, which is done by |min Q •Λ (S º) : X ↝ Ḟ D X|.

\begin{figure}
\codefigure\fontsize{10.6pt}{0pt}
\begin{code}
data CoinBag'View : {c : Coin} {n : Nat} {l : Nat} → CoinBag' c n l → Set where
  empty       :  {c : Coin} → CoinBag'View {c} {0} {0} bnil
  oneponep    :  {m l : Nat} {lep : onep ≤C onep}
                 (b : CoinBag' onep m l) → CoinBag'View {onep} {1 + m} {1 + l} (bcons onep lep b)
  oneptwop    :  {m l : Nat} {lep : onep ≤C twop}
                 (b : CoinBag' onep m l) → CoinBag'View {twop} {1 + m} {1 + l} (bcons onep lep b)
  twoptwop    :  {m l : Nat} {lep : twop ≤C twop}
                 (b : CoinBag' twop m l) → CoinBag'View {twop} {2 + m} {1 + l} (bcons twop lep b)
  onepfivep   :  {m l : Nat} {lep : onep ≤C fivep}
                 (b : CoinBag' onep m l) → CoinBag'View {fivep} {1 + m} {1 + l} (bcons onep lep b)
  twopfivep   :  {m l : Nat} {lep : twop ≤C fivep}
                 (b : CoinBag' twop m l) → CoinBag'View {fivep} {2 + m} {1 + l} (bcons twop lep b)
  fivepfivep  :  {m l : Nat} {lep : fivep ≤C fivep}
                 (b : CoinBag' fivep m l) → CoinBag'View {fivep} {5 + m} {1 + l} (bcons fivep lep b)
\end{code}
\caption{The view datatype on |CoinBag'|.}
\label{fig:CoinBag'View}
\end{figure}

\begin{sidewaysfigure}
\codefigure\fontsize{10pt}{0pt}\setlength{\blanklineskip}{-3.5pt}
\begin{code}
greedy-lemma :  (c d : Coin) → c ≤C d → (m n : Nat) → value c + m ≡ value d + n →

                (l : Nat) (b : CoinBag' c m l) → (Σ'(l' ∶ Nat)) CoinBag' d n l' × (l' ≤ l)

greedy-lemma          c               d      c≤d  {-""-}   m                n        eq             l                   b  with view-ordered-coin c d c≤d

greedy-lemma {-"."-}  onep   {-"."-}  onep   _    {-"."-}  n                n        refl           l                   b(vartype(CoinBag' onep n l))  | oneponep = (goal(Σ'(l' ∶ Nat) CoinBag' onep n l' × (l' ≤ l))(0))

greedy-lemma {-"."-}  onep   {-"."-}  twop   _    {-"."-}  (1 + n)          n        refl           l                   b  | oneptwop   with view-CoinBag' b

greedy-lemma {-"."-}  onep   {-"."-}  twop   _    {-"."-}  (1 + n)          n        refl  {-"."-}  (1 + l'')  {-"."-}  _  | oneptwop   | oneponep {.n} {l''} b(vartype(CoinBag' onep n l'')) =
{-"\hfill"-} (goal(Σ'(l' ∶ Nat) CoinBag' twop n l' × (l' ≤ 1 + l''))(1))

greedy-lemma {-"."-}  onep   {-"."-}  fivep  _    {-"."-}  (4 + n)          n        refl           l                   b  | onepfivep  with view-CoinBag' b

greedy-lemma {-"."-}  onep   {-"."-}  fivep  _    {-"."-}  (4 + n)          n        refl  {-"."-}  _          {-"."-}  _  | onepfivep  | oneponep          b  with view-CoinBag' b

greedy-lemma {-"."-}  onep   {-"."-}  fivep  _    {-"."-}  (4 + n)          n        refl  {-"."-}  _          {-"."-}  _  | onepfivep  | oneponep {-"."-}  _  | oneponep          b  with view-CoinBag' b

greedy-lemma {-"."-}  onep   {-"."-}  fivep  _    {-"."-}  (4 + n)          n        refl  {-"."-}  _          {-"."-}  _  | onepfivep  | oneponep {-"."-}  _  | oneponep {-"."-}  _  | oneponep          b  with view-CoinBag' b

greedy-lemma {-"."-}  onep   {-"."-}  fivep  _    {-"."-}  (4 + n)          n        refl  {-"."-}(4 + l'')    {-"."-}  _  | onepfivep  | oneponep {-"."-}  _  | oneponep {-"."-}  _  | oneponep {-"."-}  _  | oneponep {.n} {l''} b(vartype(CoinBag' onep n l'')) =

{-"\hfill"-} (goal(Σ'(l' ∶ Nat) CoinBag' fivep n l' × (l' ≤ 4 + l''))(2))

greedy-lemma {-"."-}  twop   {-"."-}  twop   _    {-"."-}  n                n        refl           l                   b(vartype(CoinBag' twop n l))  | twoptwop = (goal(Σ'(l' ∶ Nat) CoinBag' twop n l' × (l' ≤ l))(3))

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (3 + n)          n        refl           l                   b  | twopfivep  with view-CoinBag' b

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (3 + n)          n        refl  {-"."-}  _          {-"."-}  _  | twopfivep  | oneptwop          b  with view-CoinBag' b

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (3 + n)          n        refl  {-"."-}  _          {-"."-}  _  | twopfivep  | oneptwop {-"."-}  _  | oneponep        b  with view-CoinBag' b

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (3 + n)          n        refl  {-"."-}  (3 + l'')  {-"."-}  _  | twopfivep  | oneptwop {-"."-}_  | oneponep {-"."-}  _  | oneponep {.n} {l''} b(vartype(CoinBag' onep n l'')) =

{-"\hfill"-} (goal(Σ'(l' ∶ Nat) CoinBag' fivep n l' × (l' ≤ 3 + l''))(4))

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (3 + n)          n        refl  {-"."-}  _          {-"."-}  _  | twopfivep  | twoptwop          b  with view-CoinBag' b

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (3 + n)          n        refl  {-"."-}  (2 + l'')  {-"."-}  _  | twopfivep  | twoptwop {-"."-}  _  | oneptwop {.n}  {l''} b(vartype(CoinBag' twop n l'')) =

{-"\hfill"-} (goal(Σ'(l' ∶ Nat) CoinBag' fivep n l' × (l' ≤ 2 + l''))(5))

greedy-lemma {-"."-}  twop   {-"."-}  fivep  _    {-"."-}  (4 + k) {-"."-}  (1 + k)  refl  {-"."-}  (2 + l'')  {-"."-}  _  | twopfivep  | twoptwop {-"."-}  _  | twoptwop {k}   {l''} b(vartype(CoinBag' twop k l'')) =

{-"\hfill"-} (goal(Σ'(l' ∶ Nat) CoinBag' fivep (1 + k) l' × (l' ≤ 2 + l''))(6))

greedy-lemma {-"."-}  fivep  {-"."-}  fivep  _    {-"."-}  n                n        refl           l                   b(vartype(CoinBag' fivep n l))  | fivepfivep = (goal(Σ'(l' ∶ Nat) CoinBag' fivep n l' × (l' ≤ l))(7))
\end{code}
\vskip-10pt
\caption{Cases of |greedy-lemma|, generated semi-automatically by Agda's interactive case-split mechanism.
Goal types are shown in the interaction points, and the types of some pattern variables are shown in subscript beside them.}
\label{fig:greedy-lemma}
\end{sidewaysfigure}

Back to the minimum coin change problem:
By |fun-preserves-fold|, the specification |min-coin-change| is equivalent to
\begin{code}
min (fun size º • leq • fun size) •Λ ((cata(fun total-value-alg)) º)
\end{code}
which matches the form of the generic specification given in the Greedy Theorem, so we try to discharge the two conditions of the theorem.
The monotonicity condition reduces to monotonicity of |fun size-alg| on |leq|, and can be easily proved either by relational calculation or pointwise reasoning.
As for the greedy condition, an obvious choice for~|Q| is an ordering that leads us to choose the largest possible denomination, so we go for
\begin{code}
Q :  Ḟ ⌊ CoinBagOD ⌋ (const Nat) ↝ Ḟ ⌊ CoinBagOD ⌋ (const Nat)
Q (`nil   ,      tt  ) = return (`nil , tt)
Q (`cons  , d ,  _   ) = ((lambda(e rest)) `cons , e , rest) <$>² (_≤C_ d) any
\end{code}
where, in the cons case, the output is required to be also a cons node, and the coin at its head position must be one that is no smaller than the coin~|d| at the head position of the input.
It is non-trivial to prove the greedy condition by relational calculation.
Here we offer instead a brute-force yet conveniently expressed case analysis by dependent pattern matching.
Define a new datatype |CoinBag'| by composing two algebraic ornaments on |⌊ CoinBagOD ⌋| in parallel:
\begin{code}
CoinBag'OD : OrnDesc (proj₁ ⋈ proj₁) pull ⌊ CoinBagOD ⌋
CoinBag'OD =  ⌈ algOD ⌊ CoinBagOD ⌋ (fun total-value-alg) ⌉ ⊗
              ⌈ algOD ⌊ CoinBagOD ⌋ (fun size-alg) ⌉

CoinBag' : Coin → Nat → Nat → Set
CoinBag' = μ ⌊ CoinBag'OD ⌋ (ok (c , n) , ok (c , l))
\end{code}
whose two constructors can be specialised to
\begin{code}
bnil   :  {c : Coin} → CoinBag' c 0 0

bcons  :  {c : Coin} {n l : Nat} → (d : Coin) → d ≤C c →
          CoinBag' d n l → CoinBag' c (value d + n) (1 + l)
\end{code}
By predicate swapping using the modularity isomorphisms (\autoref{sec:predicate-swapping}) and |fun-preserves-fold|, |CoinBag'| is characterised by the isomorphisms
\begin{flalign}
&\hskip\mathindent |CoinBag' c n l ≅ (Σ'(b ∶ CoinBag c)) (total-value b ≡ n) × (size b ≡ l)| &
\label{eq:CoinBag'}
\end{flalign}
for all |c : Coin|, |n : Nat|, and |l : Nat|.
Hence a coin bag of type |CoinBag' c n l| contains |l|~coins that are no larger than~|c| and sum up to |n|~pence.
The greedy condition then essentially reduces to this lemma:
\begin{code}
greedy-lemma :  (c d : Coin) → c ≤C d →
                (m n : Nat) → value c + m ≡ value d + n →
                (l : Nat) (b : CoinBag' c m l) →
                (Σ'(l' ∶ Nat)) CoinBag' d n l' × (l' ≤ l)
\end{code}
That is, given a problem (i.e., a value to be represented by coins), if |c : Coin| is a choice of decomposition (i.e., the first coin used) no better than |d : Coin| (i.e., |c ≤C d| --- recall that we prefer larger denominations), and |b : CoinBag' c m l| is a solution of size~|l| to the remaining subproblem~|m| resulting from choosing~|c|, then there is a solution to the remaining subproblem~|n| resulting from choosing~|d| whose size~|l'| is no greater than~|l|.
We define two \emph{views}~\citep{McBride-view} --- or ``customised pattern matching'' --- to aid the analysis:
\begin{itemize}
\item The first view analyses a proof of |c ≤C d| and exhausts all possibilities of |c|~and~|d|,
\begin{code}
data CoinOrderedView : Coin → Coin → Set where
  oneponep    : CoinOrderedView  onep   onep
  oneptwop    : CoinOrderedView  onep   twop
  onepfivep   : CoinOrderedView  onep   fivep
  twoptwop    : CoinOrderedView  twop   twop
  twopfivep   : CoinOrderedView  twop   fivep
  fivepfivep  : CoinOrderedView  fivep  fivep

view-ordered-coin : (c d : Coin) → c ≤C d → CoinOrderedView c d
\end{code}
where the covering function |view-ordered-coin| is written by standard pattern matching on |c| and~|d|.
\item The second view analyses some |b : CoinBag' c n l| and exhausts all possibilities of |c|, |n|, |l|, and the first coin in~|b| (if any).
The view datatype |CoinBag'View| is shown in \autoref{fig:CoinBag'View}, and the covering function
\begin{code}
view-CoinBag' :
  {c : Coin} {n l : Nat} (b : CoinBag' c n l) → CoinBag'View b
\end{code}
is again written by standard pattern matching.
\end{itemize}
Given these two views, the function |greedy-lemma| can be split into eight cases by first exhausting all possibilities of |c| and~|d| with |view-ordered-coin| and then analysing the content of~|b| with |view-CoinBag'|.
\autoref{fig:greedy-lemma} shows the case-split tree generated semi-automatically by Agda; the detail is explained as follows:
\begin{itemize}
\item At Goal~0 (and similarly Goals 3 and~7), the input bag is |b : CoinBag' onep n l|, and we should produce a |CoinBag' onep n l'| for some |l' : Nat| such that |l' ≤ l|.
This is easy because |b|~itself is a suitable bag.
\item At Goal~1 (and similarly Goals 2, 4, and~5), the input bag has type\break |CoinBag' onep (1 + n) l|, i.e., the coins in the bag are no larger than |onep| and the total value is |1 + n|.
The bag must contain |onep| as its first coin; let the rest of the bag be |b : CoinBag' onep n l''|.
At this point Agda can deduce that |l| must be |1 + l''|.
Now we can return |b| as the result after the upper bound on its coins is relaxed from |onep| to |twop|, which is done by
\begin{code}
relax {-"\kern-1pt"-}:{-"\kern-1pt"-} {c d : Coin} {-"\kern-1.5pt"-} {n l : Nat} → c ≤C d → CoinBag' c n l → CoinBag' d n l
\end{code}
\item The remaining Goal~6 is the most interesting one:
The input bag has type |CoinBag' twop (3 + n) l|, which in this case contains two 2-pence coins, and the rest of the bag is |b : CoinBag' twop k l''|.
Agda deduces that |n|~must be |1 + k| and |l|~must be |2 + l''|.
We thus need to add a penny to~|b| to increase its total value to |1 + k|, which is done by
\begin{code}
add-penny :
  {c : Coin} {n l : Nat} → CoinBag' c n l → CoinBag' c (1 + n) (1 + l)
\end{code}
and relax the bound of |add-penny b| from |twop| to |fivep|.
\end{itemize}
The above case analysis may look tedious, but note that Agda is able to
\begin{itemize}
\item produce all the cases (modulo some cosmetic revisions) after the programmer decides to use the two views and instructs Agda to do case splitting accordingly, and
\item manage all the bookkeeping and deductions about the total value and the size of bags with dependent pattern matching,
\end{itemize}
so the overhead on the programmer's side is actually less than it seems.
The greedy condition can now be discharged by pointwise reasoning, using~(\ref{eq:CoinBag'}) to interface with |greedy-lemma|.
We conclude that the Greedy Theorem is applicable, and obtain
\begin{code}
(cata((min Q •Λ (fun total-value-alg º)) º)) º ⊆ min-coin-change
\end{code}
We have thus found the algebra
\begin{code}
R = (min Q •Λ (fun total-value-alg º)) º
\end{code}
which will help us to construct the final internalist program.

\subsubsection{Constructing the internalist program}

As planned, we synthesise a new datatype by ornamenting |CoinBag| using the algebra~|R| derived above:
\begin{code}
GreedyBagOD : OrnDesc (Coin × Nat) proj₁ ⌊ CoinBagOD ⌋
GreedyBagOD = algOD ⌊ CoinBagOD ⌋ R

GreedyBag : Coin → Nat → Set
GreedyBag c n = μ ⌊ GreedyBagOD ⌋ (c , n)
\end{code}
whose two constructors can be given the following types:
\begin{code}
gnil   :  {c : Coin} {n : Nat} →
          total-value-alg (`nil , tt) ≡ n →
          (  (ns : Ḟ ⌊ CoinBagOD ⌋ (const Nat)) →
               total-value-alg ns ≡ n → Q ns (`nil , tt)) →
          GreedyBag c n

gcons  :  {c : Coin} {n : Nat} (d : Coin) (d≤c : d ≤C c) →
          {n' : Nat} → total-value-alg (`cons , d , d≤c , n') ≡ n →
          (  (ns : Ḟ ⌊ CoinBagOD ⌋ (const Nat)) →
               total-value-alg ns ≡ n → Q ns (`cons , d , d≤c , n')) →
          GreedyBag d n' → GreedyBag c n
\end{code}
and implement the greedy algorithm by
\begin{code}
greedy : (c : Coin) (n : Nat) → GreedyBag c n
\end{code}
Let us first simplify the two constructors of |GreedyBag|.
Each of the two constructors has two additional proof obligations coming from the algebra~|R|:
\begin{itemize}
\item For |gnil|,
\begin{itemize}
\item the first obligation |total-value-alg (`nil , tt) ≡ n| reduces to |0 ≡ n|, so we may discharge the obligation by specialising~|n| to~|0|;
\item for the second obligation, |ns|~is necessarily |(`nil , tt)| if |total-value-alg ns ≡ 0|, and indeed |Q|~maps |(`nil , tt)| to |(`nil , tt)|, so the second obligation can be discharged as well.
\end{itemize}
We thus obtain a simplified version of |gnil|:
\begin{code}
gnil' : {c : Coin} → GreedyBag c 0
\end{code}
\item For |gcons|,
\begin{itemize}
\item the first obligation reduces to |value d + n' ≡ n|, so we may just specialise~|n| to |value d + n'| and discharge the obligation;
\item for the second obligation, any~|ns| satisfying |total-value-alg ns ≡ value d + n'| must be of the form |(`cons , e , e≤c , m' , tt)| for some |e : Coin|, |e≤c : e ≤C c|, and |m' : Nat| since the right-hand side |value d + n'| of the equality is non-zero, and |Q|~maps~|ns| to |(`cons , d , d≤c , n' , tt)| if |e ≤C d|, so |d|~should be the largest ``usable'' coin if this obligation is to be discharged.
We say that |d : Coin| is \emph{usable} with respect to some |c : Coin| and |n : Nat| if |d|~is bounded above by~|c| and can be part of a solution to the problem for |n|~pence:
\begin{code}
UsableCoin : Nat → Coin → Coin → Set
UsableCoin n c d = (d ≤C c) × ((Σ'(n' ∶ Nat)) value d + n' ≡ n)
\end{code}
The obligation can then be rewritten as
\begin{code}
(e : Coin) → UsableCoin (value d + n') c e → e ≤C d
\end{code}
which requires that |d|~is the largest usable coin with respect to |c|~and |value d + n'|.
This obligation is the only one that cannot be trivially discharged, since it requires computation of the largest usable coin.
\end{itemize}
We thus specialise |gcons| to
\begin{code}
gcons' :  {c : Coin} (d : Coin) → d ≤C c →
          {n' : Nat} →
          ((e : Coin) → UsableCoin (value d + n') c e → e ≤C d) →
          GreedyBag d n' → GreedyBag c (value d + n')
\end{code}
\end{itemize}
Because of |gcons'|, we are directed to implement a function |maximum-coin| that computes the largest usable coin with respect to any |c : Coin| and non-zero |n : Nat|:
\begin{code}
maximum-coin :
  (c : Coin) (n : Nat) → n > 0 →
  (Σ'(d ∶ Coin))  UsableCoin n c d × ((e : Coin) → UsableCoin n c e → e ≤C d)
\end{code}
This takes some theorem proving but is overall a typical Agda exercise in dealing with natural numbers and ordering.
Finally, the greedy algorithm is implemented as the following internalist program, which repeatedly uses |maximum-coin| to find the largest usable coin and unfolds a |GreedyBag|:
\begin{code}
greedy : (c : Coin) (n : Nat) → GreedyBag c n
greedy c n = <-rec P f n c
  where
    P : Nat → Set
    P n = (c : Coin) → GreedyBag c n
    f : (n : Nat) → ((n' : Nat) → n' < n → P n') → P n
    f          n               rec  c  with compare-with-zero n 
    f {-"."-}  0               rec  c  | is-zero = gnil'
    f          n               rec  c  | above-zero n>z   with maximum-coin c n n>z
    f {-"."-}  (value d + n')  rec  c  | above-zero n>z   |  d , (d≤c , n' , refl) , guc = {-"\quad"-}
                                                             gcons' d d≤c guc (rec n' (goal()(8)) d)
\end{code}
In |greedy|, the combinator
\begin{code}
<-rec :  (P : Nat → Set) →
         ((n : Nat) → ((n' : Nat) → n' < n → P n') → P n) →
         (n : Nat) → P n
\end{code}
is for well-founded recursion on~|_<_|\,, and the function
\begin{code}
compare-with-zero : (n : Nat) → ZeroView n
\end{code}
is a covering function for the view
\begin{code}
data ZeroView : Nat → Set where
  is-zero     :  ZeroView 0
  above-zero  :  {n : Nat} → n > 0 → ZeroView n
\end{code}
At Goal~8, Agda deduces that |n|~is |value d + n'| and demands that we prove |n' < value d + n'| in order to make the recursive call, which is easily discharged since |value d > 0|.

\section{Discussion}

\todo[inline]{compare the \citet{McBride-ornaments} version (compatible with the two-constructor universe) and the \citet{Dagand-functional-ornaments} version of algebraic ornamentation in terms of ``quality'' (amount of~|σ|'s used); proof-relevant Algebra of Programming (e.g., |fun-preserves-fold|; linking to the next chapter); related work: \citet{Atkey-refining-inductive-types}}