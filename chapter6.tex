\chapter{Categorical equivalence of ornaments and relational algebras}
\label{chap:equivalence}

Consider the |AlgList| datatype in \autoref{sec:algOD} again.
The way it is refined relative to |List| looks canonical, in the sense that any ornamentation of |List| can be programmed as a special case of |AlgList|:
we can choose whatever index set we want by setting the carrier of the algebra~|R|, and by carefully programming~|R|, we can insert fields into the list datatype that add more information or put restriction on fields and indices.
For example, if we want some new information in the nil case, we can program~|R| such that |R (`nil , tt) x| contains a field requesting that information; if, in the cons case, we need the targeted index~|x|, the head element~|a|, and the index~|x'| of the recursive position to be related in some way, we can program~|R| such that |R (`cons , a , x' , tt) x| expresses that relationship.

The above observation leads to the following general theorem:
Let |O : Orn e D E| be an ornament from |D : Desc I| to |E : Desc J|.
Then there is a \key{classifying algebra} for~|O|
\begin{code}
clsAlg O : Ḟ D (Inv' e) ↝ Inv' e
\end{code}
whose the carrier type is defined by
\begin{code}
Inv' e : I → Set
Inv' e i = (Σ'(j ∶ J)) e j ≡ i
\end{code}
such that there are isomorphisms
\begin{code}
(j : J) → μ ⌊ algOD D (clsAlg O) ⌋ (e j , j , refl) ≅ μ E j
\end{code}
That is, the algebraic ornamentation of~|D| using the classifying algebra derived from~|O| produces a datatype isomorphic to~|μ E|, so intuitively the algebraic ornamentation has the same content as~|O|.
We may interpret this theorem as saying that algebraic ornamentation is ``complete'' for the ornament language: any relationship between datatypes that can be described by an ornament can be described up to isomorphism by an algebraic ornamentation.
The name ``classifying algebra'' is explained after the examples below.

\block{Examples}{classifying algebras for two ornaments}{
The following relational algebra~|R| serves as a classifying algebra for the ornament |⌈ OrdListOD ⌉| from lists to ordered lists:
\begin{code}
R : Ḟ (ListD Val) (Inv' !) ↝ Inv' !  -- |! : Val → ⊤|
R (`nil   ,                    tt) (b , refl) = ⊤
R (`cons  , x , (b' , refl) ,  tt) (b , refl) = (b ≤ x) × (b' ≡ x)
\end{code}
The nil case says that the empty list can be mapped to any~|b| (since any |b : Val| is a lower bound of the empty list); for the cons case, where |x : Val| is the head element of a non-empty list and |b'|~is a possible result of folding the tail (i.e., |b' : Val| is a lower bound of the tail), the list can be mapped to~|b| if |b : Val| is a lower bound of~|x| and |x|~is exactly~|b'|.
The type of proofs that a list~|xs| folds to some~|b| with~|R| is isomorphic to |Ordered b xs|, and hence
\begin{code}
AlgList Val R (b , refl)  ≅ (Σ'(xs ∶ List Val)) (cata(R)) xs (b , refl)  {-""-}
                          ≅ (Σ'(xs ∶ List Val)) Ordered b xs             ≅ OrdList b
\end{code}

For another example, consider the ornament |NatD-ListD A|, for which we can use the following classifying algebra~|S|:
\begin{code}
S : Ḟ NatD (Inv' !) ↝ Inv' !  -- where |! : ⊤ → ⊤|
S (`nil   ,                tt) (tt , refl) = ⊤
S (`cons  , (tt , refl) ,  tt) (tt , refl) = A
\end{code}
The result of folding a natural number~|n| with~|S| is uninteresting, as it can only be~`|tt|'.
The fold, however, requires an element of type~|A| for each successor node it encounters, so a proof that |n|~goes through the fold consists of |n|~elements of type~|A| and amounts to an inhabitant of |Vec A n|.
Thus
\begin{code}
μ ⌊ algOD NatD S ⌋ (tt , tt , refl)  ≅ (Σ'(n ∶ Nat)) (cata(S)) n (tt , refl)  {-""-}
                                     ≅ (Σ'(n ∶ Nat)) Vec A n                  ≅ List A
\end{code}
This example helps to emphasise \emph{proof-relevance} of our relational language, deviating from \citet{Bird-AoP}, which (implicitly) adopts the traditional proof-irrelevant semantics of relations (in the sense that all one cares about proofs of set membership is their existence).}

The completeness theorem brings up a nice algebraic intuition about inductive families.
Consider the ornament from lists to vectors, for example.
This ornament specifies that the type |List A| is refined by the collection of types |Vec A n| for all |n : Nat|.
A list, say |a ∷ b ∷ [] : List A|, can be reconstructed as a vector by starting in the type |Vec A zero| as~|[]|, jumping to the next type |Vec A (suc zero)| as |b ∷ []|, and finally landing in |Vec A (suc (suc zero))| as |a ∷ b ∷ []|.
The list is thus \emph{classified} as having length~$2$, as computed by the fold function |length|, and the resulting vector is a fused representation of the list and the classification proof.
In the case of vectors, this classification is total and deterministic: every list is classified under one and only one index.
But in general, classifications can be partial and nondeterministic.
For example, promoting a list to an ordered list is classifying the list under an index that is a lower bound of the list.
The classification process checks at each jump whether the list is still ordered; this check can fail, so an unordered list would ``disappear'' midway through the classification.
Also there can be more than one lower bound for an ordered list, so the list can end up being classified under any one of them.
Compared with \varcitet{McBride-ornaments}{'s original functional algebraic ornamentation}, which can only capture part of this intuition about classification (namely those classifications that are total and deterministic), relational algebraic ornamentation allows partiality and nondeterminacy and thus captures the idea about classification in its entirety --- a classification is just a relational fold computing the index that classifies an inhabitant.
All ornaments specify classifications, and thus can be transformed into algebraic ornamentations.

There is a dual to the completeness theorem: every relational algebra is isomorphic to the classifying algebra for the algebraic ornament using the algebra.
More precisely: Let |D : Desc I| be a description and |R : Ḟ D X ↝ X| an algebra (where |X : I → Set|).
There is a family of isomorphisms between |X i|~and |Inv' proj₁ i| for every |i : I| (where |proj₁ : Σ I X → I|); call the forward direction of this family of isomorphisms |h : X ⇉ Inv' proj₁|.
Then we have
\begin{code}
fun h • R ≃ clsAlg ⌈ algOD D R ⌉ • Ṙ D (fun h)
\end{code}
or diagrammatically:
\[ \begin{tikzpicture}[x=12em,y=3em, text height=1.5ex, text depth=.25ex]
\node(X)                  {|X|};
\node(FDX) [below=1 of X] {|Ḟ D X|};
\node(I)   [right=1 of X] {|Inv' proj₁|};
\node(FDI) [below=1 of I] {|Ḟ D (Inv' proj₁)|};
\draw[-> ] (FDX) edge node[left]{|R|} (X);
\draw[-> ] (FDI) edge node[right]{\rlap{|clsAlg ⌈ algOD D R ⌉|}} (I);
\draw[<->] (FDX) edge node(RDh)[below,xshift=15pt]{|Ṙ D (fun h)|} node(iso)[horizontal label on arrow,xshift=-35pt,yshift=-.25pt]{\,|≅|\,} (FDI)
           (X)   edge (I);
\node at (X -|| iso) [horizontal label on arrow,yshift=-.25pt]{\,|≅|\,};
\node at (X -|| RDh) [above]{|fun h|};
\end{tikzpicture} \]
Together with the completeness theorem, we see that |algOD| and |clsAlg| are, in some sense, inverse to each other up to isomorphism.
This suggests that we can seek to construct an \key{equivalence} between |SliceCategory Ōrn (I , D)| and a suitable category of |D|-algebras and homomorphisms by extending |algOD| and |clsAlg| to functors between the two categories and proving that the two functors are inverse up to (natural) isomorphism.
This we do in \autoref{sec:ornaments-and-relational-algebras}, after we look at ornaments from a more semantic perspective in \autoref{sec:ornaments-and-horizontal-transformations}, where we also deal with some unresolved issues in \autoref{chap:categorical}.
The equivalence shows that ornaments and relational algebras are essentially the same entities, which lets us associate some ornamental and relational algebraic constructions in \autoref{sec:equivalence-consequences}.
\autoref{sec:equivalence-discussion} concludes with some discussion.

\todo[inline]{see if the above can be revised to be slightly more specific; reduced formalisation}


\section{Ornaments and horizontal transformations}
\label{sec:ornaments-and-horizontal-transformations}

We first aim to find a semantic perspective of ornaments, so we can step away from the syntactic detail and handle ornaments more easily, in preparation for \autoref{sec:ornaments-and-relational-algebras}.
Consider the equivalence on ornaments that was left undefined in \autoref{sec:concrete-categories}:
\begin{code}
OrnEq :  {I J : Set} {e f : J → I} {D : Desc I} {E : Desc J} →
         Orn e D E → Orn f D E → Set
\end{code}
Here we aim for an extensional equality --- for example, if the only difference between two ornaments is either
\begin{itemize}
\item that one uses~|σ S| and the other uses |(Δ''(s ∶ S)) (∇''(s))|, both expressing copying, or
\item that one uses
\begin{code}
(Δ''(s ∶ S)) (Δ''(t ∶ T)) (∇''(f s)) (∇''(g t))
\end{code}
and the other uses
\begin{code}
(Δ''(s ∶ S)) (∇''(f s)) (Δ''(t ∶ T)) (∇''(g t))
\end{code}
the latter swapping the order of the middle two independent markings,
\end{itemize}
then it seems pointless to distinguish the two ornaments.
Since the direct semantics of ornaments is decoded componentwise by |erase|, we might define |OrnEq| as pointwise equality of |erase|, which requires a rather tricky type to express.
However, it turns out that we can focus on only one aspect of |erase|: fixing two response descriptions related by at least one response ornament, the two response descriptions necessarily have the same pattern of recursive positions and |erase| always copies the values at the positions, so the only behaviour of |erase| that can vary with response ornaments is how the values of the \emph{fields} are transformed.
This suggests that, in an inhabitant of |⟦ D ⟧ X| where |D : RDesc I| and |X : I → Set|, we can separate the values of the fields from the values at the recursive positions, and focus on how |erase| acts on the first part.

Here \key{indexed containers}~\citep[Chapter~8]{Morris-thesis} can provide a helpful perspective:
An |I|-indexed container is a set~|S| of \key{shapes}, a shape-indexed family of sets |P : S → Set| of \key{positions}, and a function |next : (s : S) → P s → I| associating each position with an index of type~|I|.
(The terminology slightly deviates from that of \citeauthor{Morris-thesis}, whose indexed containers refer to indexed families of the above indexed containers, directly comparable with the two-level structure of descriptions.)
The container is interpreted as the type
\begin{code}
(lambda(X)) (Σ'(s ∶ S)) ((p : P s) → X (next s p)) : (I → Set) → Set
\end{code}
That is, given a type family |X : I → Set|, an inhabitant of the container type starts with a specific shape --- from which we derive a set of positions and associated indices --- and contains an element of type~|X i| for each of the positions where |i|~is the index associated with the position.
(For example, take~|S| to be the set of natural numbers, and let the set of positions derived from a natural number~|n| be a finite set of size~|n|, enumerable in a fixed order.
The container type is then isomorphic to the type of lists, whose elements are indexed in accordance with the |next| function.)
Response descriptions can be regarded as a special case of indexed containers: values of fields constitute a shape, and sets of positions are restricted to finite sets; consequently, |next s : P s → I| for any |s : S| can be represented by a |List I|, and there is no longer need to specify~|P|.
We thus define the set of shapes derived from a response description by
\begin{code}
Ṡ : {I : Set} → RDesc I → Set
Ṡ (ṿ is)   = ⊤
Ṡ (σ S D)  = (Σ'(s ∶ S)) Ṡ (D s)
\end{code}
and the function |next| by
\begin{code}
next : {I : Set} (D : RDesc I) → Ṡ D → List I
next (ṿ is)   tt        = is
next (σ S D)  (s , ss)  = next (D s) ss
\end{code}
We can then express that a piece of horizontal data of type |⟦ D ⟧ X| can be separated into a shape and a series of contained elements via the following isomorphism:
\begin{code}
horizontal-iso :  {I : Set} (D : RDesc I) (X : I → Set) →
                  ⟦ D ⟧ X ≅ Σ (Ṡ D) (flip Ṗ X ∘ next D)
\end{code}
The implementation is just rearrangement of data --- for example, the left-to-right direction is defined by
\begin{code}
hori-decomp :  {I : Set} (D : RDesc I) (X : I → Set) →
               ⟦ D ⟧ X → Σ (Ṡ D) (flip Ṗ X ∘ next D)
hori-decomp (ṿ is)   X xs        = tt , xs
hori-decomp (σ S D)  X (s , hs)  = (pair s * id) (hori-decomp (D s) X hs)
\end{code}

Back to the semantic equivalence of ornaments.
Define a specialised version of |erase| on shapes:
\begin{code}
erase-Ṡ :  {I J : Set} {e : J → I} {D : RDesc I} {E : RDesc J}
           (O : ROrn e D E) → Ṡ E → Ṡ D
erase-Ṡ (ṿ eqs)  tt        = tt
erase-Ṡ (σ S O)  (s , ss)  = s ,  erase-Ṡ (O s)  ss
erase-Ṡ (Δ T O)  (t , ss)  =      erase-Ṡ (O t)  ss
erase-Ṡ (∇ s O)  ss        = s ,  erase-Ṡ O      ss
\end{code}
This is the aspect of |erase| that we are interested in, and we can now define equivalence of ornaments as
\begin{code}
OrnEq :  {I J : Set} {e f : J → I} {D : Desc I} {E : Desc J} →
         Orn e D E → Orn f D E → Set
OrnEq {I} {J} {e} {f} O P =
  (e ≐ f) × ((j : J) → erase-Ṡ (O (ok j)) ≊' erase-Ṡ (P (ok j)))
\end{code}
which can be proved to imply pointwise equality of |forget O| and |forget P| by (datatype-generic) induction on their input:
With the help of |horizontal-iso|, the general |erase| can be seen as first separating a piece of horizontal data into a shape and a series of recursive values, processing the shape by |erase-Ṡ|, and combining the resulting shape with the recursive values.
Since the real work is done by |erase-Ṡ|, requiring extensional equality of |erase-Ṡ| is sufficient.
This argument is then extended vertically by induction.

We have seen that response ornaments induce shape transformations (by |erase-Ṡ|).
Conversely, can we derive response ornaments from shape transformations?
More specifically: Let |D : RDesc I|, |E : RDesc J|, and |t : Ṡ E → Ṡ D|, and we wish to construct a response ornament from~|D| to~|E|.
The shape transformation~|t| expects a complete |Ṡ E| as its argument, which, in the response ornament, can be assembled by first marking all fields of~|E| as additional by~|Δ|.
We then apply~|t| to the assembled shape |ss : Ṡ E|, resulting in a shape |t ss : Ṡ D|, and fill out all fields of~|D| using values in this shape by~|∇|.
Finally, we have to use~|ṿ| to end the response ornament, which requires an index coherence proof of type |Ė e (next E ss) (next D (t ss))| for some |e : J → I| --- this is the extra condition that we need to impose on the shape transformation for deriving a response ornament.
We thus define \key{horizontal transformations} as
\begin{code}
record HTrans {I J : Set} (e : J → I) (D : RDesc I) (E : RDesc J) : Set
  where
    constructor pair
    field
      t  : Ṡ E → Ṡ D
      c  : (ss : Ṡ E) → Ė e (next E ss) (next D (t ss))
\end{code}
The response ornaments derived by the above process are called \key{normal response ornaments}, which are defined by
\begin{code}
normROrn-∇ :  {I J : Set} {e : J → I} {D : RDesc I} {js : List J} →
              (ss ∶ Ṡ D) → Ė e js (next D ss) → ROrn e D (ṿ js)
normROrn-∇ {D := ṿ is   } tt        eqs = ṿ eqs
normROrn-∇ {D := σ S D  } (s , ss)  eqs = (∇'(s)) normROrn-∇ {D := D s} ss eqs

normROrn :  {I J : Set} {e : J → I} {D : RDesc I} {E : RDesc J} →
            HTrans e D E → ROrn e D E
normROrn {E := ṿ js   } tr = normROrn-∇ (HTrans.t tr tt) (HTrans.c tr tt)
normROrn {E := σ S E  } tr =
  (Δ'(s ∶ S)) normROrn {E := E s} (curry (HTrans.t tr) s , curry (HTrans.c tr) s)
\end{code}
The top-level function |normROrn| exhausts all fields of~|E| by~|Δ|, partially applying the transformation along the way, and then |normROrn-∇| takes over and inserts values obtained from the result of the transformation into fields of~|D| by~|∇|, ending with the placement of the index coherence proof.

We can now easily arrange a category |ḞHTrans| of descriptions and horizontal transformations, which is isomorphic to |Ōrn|.
Its objects are of type |Σ Set Desc| as in |Ōrn|, and its sets of morphisms are
\begin{code}
λ case (J , E) (I , D) mapsto (Σ'(e : J → I)) FHTrans e D E endcase
\end{code}
where |FHTrans| is the type of \key{families of horizontal transformations}, defined in the usual way:
\begin{code}
FHTrans : {I J : Set} → (J → I) → Desc I → Desc J → Set
FHTrans {I} {J} e D E = (j : J) → HTrans e (D (e j)) (E j)
\end{code}
Morphism equivalence is defined to be pointwise equality of the shape transformations extracted by |HTrans.t|, and identities and composition are defined in terms of functional identities and composition.
We then have two functors |Erase : Functor Ōrn ḞHTrans| and |Normal : Functor ḞHTrans Ōrn| back and forth between the two categories: the object parts of both functors are identities, and for the morphism parts, |Erase| maps ornaments to componentwise |erase-Ṡ| (with suitable coherence proofs) and |Normal| maps families of horizontal transformations to normal ornaments (i.e., componentwise normal response ornaments).
For any |tr : HTrans e D E|, we can prove that
\begin{code}
erase-Ṡ (normROrn tr) ≐ HTrans.t tr
\end{code}
which guarantees that the morphism parts of |Erase| and |Normal| are inverse to each other.

Knowing that |Ōrn| and |ḞHTrans| are isomorphic means that, extensionally, we can regard ornaments and horizontal transformations as the same entities and freely switch between the two notions.
For example, in \autoref{sec:parallel-composition-pullback}, where we did not have the notion of horizontal transformations yet, it was hard to establish the pullback property of parallel composition in |Ōrn|~(\ref{eq:pc-square}) by reasoning in terms of ornaments.
By switching to |ḞHTrans|, however, the proof becomes conceptually much simpler:
Due to the isomorphism between |Ōrn| and |ḞHTrans|, it suffices to prove that the image of the square~(\ref{eq:pc-square}) under |Erase| in |ḞHTrans| is a pullback.
We have the following functor |Shape| from |ḞHTrans| to |Fam|, which maps descriptions to indexed sets of shapes and discards index coherence proofs in horizontal transformations:
\begin{code}
Shape : Functor ḞHTrans Fam
Shape = record
  case  object    = λ case (I , D   ) mapsto I  , (lambda(i)) Ṡ (D i)            endcase
  sep   morphism  = λ case (e , ts  ) mapsto e  , (lambda({j})) HTrans.t (ts j)  endcase
  sep   proofs-of-laws endcase
\end{code}
The functor can be proved to be \key{pullback-reflecting}: if the image of a square in |ḞHTrans| under |Shape| is a pullback in |Fam|, then the square itself is a pullback in |ḞHTrans|.
(The proof proceeds by manipulating shape transformations in |Fam| and then constructing the missing index coherence proof.)
The problem is thus reduced to proving that the square~(\ref{eq:pc-square}) mapped into |Fam| by |Shape ⋄ Erase| is a pullback, which boils down to the isomorphism
\begin{code}
pcROD-iso O P :  Ṡ (toRDesc (pcROD O P))
                   ≅ (Σ'(p ∶ Ṡ E × Ṡ F)) erase-Ṡ O (proj₁ p) ≡ erase-Ṡ P (proj₂ p)
\end{code}
with the two equations
\begin{code}
erase-Ṡ (diffROrn-l  O P) ≐ proj₁  ∘ proj₁ ∘ Iso.to (pcROD-iso O P)
erase-Ṡ (diffROrn-r  O P) ≐ proj₂  ∘ proj₁ ∘ Iso.to (pcROD-iso O P)
\end{code}
for any |O : ROrn e D E| and |P : ROrn f D F|, provable by induction on |O|~and~|P|.
(The isomorphism and equations allow us to prove that the derived square in |Fam| is isomorphic to the componentwise set-theoretic pullback, and thus the square itself is also a pullback.)

\section{Ornaments and relational algebras}
\label{sec:ornaments-and-relational-algebras}

In this section we seek to characterise ornaments and relational algebras as essentially the same entities via an \key{equivalence of categories}, which subsumes the completeness theorem (and its dual) in the beginning of this chapter.
The definition of category equivalence is unfolded below:
\begin{itemize}
\item An equivalence between two categories consists of two functors back and forth such that their compositions are \key{naturally isomorphic} to the identity functors.
\begin{itemize}
\item A natural isomorphism between two functors |F| , |G : Functor C D| is an isomorphism in the \key{functor category} from~|C| to~|D|, whose objects are functors from~|C| to~|D| and morphisms are \key{natural transformations}.
\begin{itemize}
\item[\raisebox{2pt}{\scalebox{.4}{$\blacksquare$}}] A natural transformation from~|F| to~|G| is a way of relating the image of~|C| under~|F| to the image of~|C| under~|G|:
it consists of a morphism |φ X : object F X =D=> object G X| for each object~|X| in~|C|, which we call the \emph{components} of the natural transformation, and for any morphism |m : X =C=> Y| the following \key{naturality} diagram commutes:
\[ \begin{tikzpicture}[x=50pt,y=30pt,baseline=(phi-Y.base)]
\node(FX) {|object F X|};
\node(GX) [right=1 of FX] {|object G X|};
\node(FY) [below=1 of FX] {|object F Y|};
\node(GY) [below=1 of GX] {|object G Y|};
\draw[->] (FX) edge node[above]{|φ X|} (GX)
          (FY) edge node(phi-Y)[below]{|φ Y|} (GY)
          (FX) edge node[left ]{|morphism F m|} (FY)
          (GX) edge node[right]{|morphism G m|} (GY);
\end{tikzpicture} \]
Both equivalence and composition for natural transformations are componentwise.
\end{itemize}
\item Natural isomorphism is an equivalence relation on functors, so we can assemble a category whose objects are (smaller) categories and morphisms are functors, with natural isomorphism as the equivalence on morphisms.
An equivalence of categories is then an isomorphism in this category of categories and functors.
\end{itemize}
\end{itemize}
Fixing |D : Desc I|, the completeness theorem is a consequence of one direction of the \emph{object part} of an equivalence between |SliceCategory Ōrn (I , D)| --- which we denote by |Ōrn / (I , D)| from now on --- and the category |RAlg D| whose objects are relational |D|-algebras
\begin{code}
record RAlgebra D : Set₁ where
  constructor pair
  field
    Carrier  : I → Set
    Alg      : Ḟ D Carrier ↝ Carrier
\end{code}
and morphisms are algebra homomorphisms (which we will elaborate on later): The two functors forming the equivalence are
\savecolumns
\begin{code}
ClsAlg  : Functor (Ōrn / (I , D)) (RAlg D)
\end{code}
and
\restorecolumns
\begin{code}
AlgOrn  : Functor (RAlg D) (Ōrn / (I , D))
\end{code}
and their object parts are respectively
\[ \begin{tikzpicture}[x=2em, y=2em, baseline=(O.base), text height=1.5ex, text depth=.25ex]
\node(T) {|J , E|};
\node(B) [below=1 of T] {|I , D|};
\node(X) [right=1 of T] {|Inv' e|};
\node(FDX) at (B -|| X) {|Ḟ D (Inv' e)|};
\draw[->] (T) edge node(O)[left]{|e , O|} (B)
          (FDX) edge node[right]{|clsAlg O|} (X);
\node(M) at ($ (T) !.5! (X) $) [coordinate] {};
\node at (O -|| M) {|mapsto|};
\end{tikzpicture}
\qquad\text{and}\qquad
\begin{tikzpicture}[x=.8em, y=2em, baseline=(O.base), text height=1.5ex, text depth=.25ex]
\node(T) {|Σ I X , ⌊ algOD D R ⌋|};
\node(B) [below=1 of T] {|I , D|};
\node(X) [left=1 of T] {|X|};
\node(FDX) at (B -|| X) {|Ḟ D X|};
\draw[->] (T) edge node(O)[right]{|proj₁ , ⌈ algOD D R ⌉|} (B)
          (FDX) edge node[left]{|R|} (X);
\node(M) at ($ (T) !.5! (X) $) [coordinate] {};
\node at (O -|| M) {|mapsto|};
\end{tikzpicture} \]
The natural isomorphism between |AlgOrn ⋄ ClsAlg| and the identity functor on |Ōrn / (I , D)| consists of two natural transformations componentwise inverse to each other; their components constitute, for each ornament |O : Orn e D E|, the following isomorphism in |Ōrn / (I , D)|:
\begin{equation}
\begin{tikzpicture}[x=4em,y=4em,baseline=(B.base)]
\node(T) {|Σ I (Inv' e) , ⌊ algOD D (clsAlg O) ⌋|};
\node(T') [right=1 of T] {|J , E|};
\node(M) at ($ (T) !.5! (T') $) [coordinate] {};
\node(B) [below=1 of M] {|I , D|};
\draw[->] (T)  edge node[below left ]{\llap{|proj₁ , ⌈ algOD D (clsAlg O) ⌉|}} (B)
          (T') edge node[below right]{|e , O|} (B);
\draw[<->] (T) edge node[horizontal label on arrow,yshift=0pt]{\,|≅|\,} (T');
\end{tikzpicture}
\label{eq:AlgOrn-ClsAlg-inverse}
\end{equation}
The completeness theorem is then obtained by mapping these isomorphisms into |Fam| by |Ind ⋄ SliceF|.

Now we turn to the morphisms of |RAlg D|.
A first thought might be adopting relational homomorphisms, which we have seen in \autoref{sec:fold-fusion} --- a relational homomorphism from an algebra |(X , R)| to another algebra |(Y , S)| is a relation |H : X ↝ Y| such that |H • R ≃ S • Ṙ D H|, or diagrammatically:
\[ \begin{tikzpicture}[x=8em,y=2em,baseline=(RDH.base)]
\node(X)                  {|X|};
\node(Y)   [right=1 of X] {|Y|};
\node(FDX) [below=1 of X] {|Ḟ D X|};
\node(FDY) [below=1 of Y] {|Ḟ D Y|};
\draw[->] (FDX) edge node     [left ] {|R|}     (X)
          (FDY) edge node     [right] {|S|}     (Y)
          (X)   edge node     [above] {|H|}     (Y)
          (FDX) edge node(RDH)[below] {|Ṙ D H|} (FDY);
\end{tikzpicture} \]
Morphism equivalence is the equivalence of the relations between carriers, ignoring the homomorphism condition.
It turns out, however, that this is not the right notion of homomorphisms for establishing the categorical equivalence.
The right notion will surface as we construct the morphism part of |AlgOrn| below.

The morphism part of |AlgOrn| maps a homomorphism from |(X , R)| to |(Y , S)| to a morphism in |Ōrn / (I , D)|:
\[ \begin{tikzpicture}[x=18em, y=4em, baseline=(B.base)]
\node(T) at (0, 1.3) {};
\node(X) at (-.5, 1) {|Σ I X , ⌊ algOD D R ⌋|};
\node(Y) at ( .5, 1) {|Σ I Y , ⌊ algOD D S ⌋|};
\node(B) at (  0, 0) {|I , D|};
\draw[->] (X) edge node[above,yshift=1pt]{|(goal()(0)) , (goal()(1))|} (Y)
          (X) edge node[below left ]{|proj₁ , ⌈ algOD D R ⌉|} (B)
          (Y) edge node[below right]{|proj₁ , ⌈ algOD D S ⌉|} (B);
\end{tikzpicture} \]
To make the diagram commute, Goal~0 should be of the form |id * h| for some \emph{function} |h : X ⇉ Y|, but the closest thing we have is merely a \emph{relation} between |X|~and~|Y| --- to have an ornament between descriptions, we need to specify computation on the index sets of the descriptions, which correspond to the carriers of relational algebras, and hence we should restrict |RAlg D| to include only \emph{functional} homomorphisms:
\[ \begin{tikzpicture}[x=8em,y=2em, baseline=(RDh.base)]
\node(X)                  {|X|};
\node(Y)   [right=1 of X] {|Y|};
\node(FDX) [below=1 of X] {|Ḟ D X|};
\node(FDY) [below=1 of Y] {|Ḟ D Y|};
\draw[->] (FDX) edge node       [left ] {|R|}           (X)
          (FDY) edge node       [right] {|S|}           (Y)
          (X)   edge node       [above] {|fun h|}       (Y)
          (FDX) edge node (RDh) [below] {|Ṙ D (fun h)|} (FDY);
\end{tikzpicture} \]
The equivalence on them is refined to pointwise equality of the functions between carriers.

We continue with Goal~1, which requires an ornament from |⌊ algOD D S ⌋| to |⌊ algOD D R ⌋|.
Switching to the perspective of horizontal transformations, we should construct a function which essentially replaces a proof about~|R| with a proof about~|S| inside a shape derived from algebraic ornamentation:
For such shapes we have the following isomorphisms
\begin{code}
algROD-iso :  {I : Set} (D' : RDesc I) {X : I → Set} (P : ℘ (⟦ D' ⟧ X)) →
              Ṡ (toRDesc (algROD D' P)) ≅ Σ (⟦ D' ⟧ X) P
\end{code}
whose implementation is, again, just rearrangement of data --- for example, the left-to-right direction is defined by
\begin{code}
algROD-decomp :
  {I : Set} (D' : RDesc I) (X : I → Set) (P : ℘ (⟦ D' ⟧ X)) →
  Ṡ (toRDesc (algROD D P)) → Σ (⟦ D' ⟧ X) P
algROD-decomp (ṿ is)    X P (xs , p , tt)  = xs , p
algROD-decomp (σ S D')  X P (s , ss)       =
  (pair s * id) (algROD-decomp (D' s) X (curry P s) ss)
\end{code}
By |algROD-iso| and |horizontal-iso|, the type of shapes for an algebraic response ornamentation can be decomposed into three parts:
\begin{itemize}
\item the type of shapes for the basic response description,
\item the type of series of indices for the recursive positions, and
\item the type of proofs about the basic shape and the indices.
\end{itemize}
(For example, in the case of |AlgList A R|, the three parts are
\begin{itemize}
\item the constructor field and the element field |a : A| from |ListD A|,
\item the field |x' : X|, and
\item the |rnil| and |rcons| fields.)
\end{itemize}
Expanding the definition of |algOD|~(\autoref{fig:algOD}), at Goal~1 we should construct for every |i : I| and |x : X i| a shape transformation
\begin{equation}
\begin{tikzpicture}[y=3em, baseline=(S.base)]
\node(R) {|Ṡ (toRDesc (algROD (D i) ((R º) x)))|};
\node(R') [below=1 of R] {|Σ (⟦ D i ⟧ X) ((R º) x)|};
\node(S') [below=1 of R'] {|Σ (⟦ D i ⟧ Y) ((S º) (h x))|};
\node(S) [below=1 of S'] {|Ṡ (toRDesc (algROD (D i) ((S º) (h x))))|};
\draw[->] (R) edge node[right]{|Iso.to (algROD-iso (D i) ((R º) x)|} (R')
          (R') edge node[right]{|mapRD (D i) h * (goal()(2))|} (S')
          (S') edge node[right]{|Iso.from (algROD-iso (D i) ((S º) (h x))|}(S);
\end{tikzpicture}
\label{eq:algROD-shape-transformation}
\end{equation}
where Goal~2 requires a function of type
\begin{code}
{xs : ⟦ D i ⟧ X} → R xs x → S (mapRD (D i) h xs) (h x)
\end{code}
which, when fully quantified, is a pointwise form of
\begin{code}
fun h • R ⊆ S • Ṙ D (fun h)
\end{code}
i.e., one direction of the homomorphism condition.
This is actually the only direction of the homomorphism condition that we should impose on the functions between carriers, which is denoted by the inclusion sign in the ``semi-commutative'' diagram:
\[ \begin{tikzpicture}[x=8em, y=2em, baseline=(RDh.base)]
\node(X)                  {|X|};
\node(Y)   [right=1 of X] {|Y|};
\node(FDX) [below=1 of X] {|Ḟ D X|};
\node(FDY) [below=1 of Y] {|Ḟ D Y|};
\draw[->] (FDX) edge node(R)  [left ] {|R|}           (X)
          (FDY) edge node     [right] {|S|}           (Y)
          (X)   edge node(h)  [above] {|fun h|}       (Y)
          (FDX) edge node(RDh)[below] {|Ṙ D (fun h)|} (FDY);
\node at (R -|| h) {|⊆|};
\end{tikzpicture} \]
The reason for requiring only one direction will become clear when we consider the morphism part of |ClsAlg|.

Having constructed the morphism part of |AlgOrn|, one of the functor laws we should prove is that it preserves equivalence, and it is when doing so that we encounter the final problem: we need to prove that the shape transformation~(\ref{eq:algROD-shape-transformation}) --- whose behaviour depends on the \emph{computational content} of the homomorphism condition --- is extensionally the same for equivalent homomorphisms, but homomorphism equivalence as we defined it does not include any information about the homomorphism condition, and is hence not strong enough.
We thus see that proofs of the homomorphism condition should not be treated irrelevantly since they are used computation-relevantly in the shape transformations, and we must take their behaviour into account when defining homomorphism equivalence.
This brings us to the right notion of algebra homomorphisms, defined by
\begin{code}
record RAlgMorphism D (X , R) (Y , S) : Set₁ where
  constructor pair
  field
    h  : X ⇉ Y
    c  : (i {-"\kern-1.1pt"-}:{-"\kern-1.1pt"-} I) {-"\kern-1.1pt"-} (xs {-"\kern-1.1pt"-}:{-"\kern-1.1pt"-} ⟦ D i ⟧ X) {-"\kern-1.1pt"-} (x {-"\kern-1.1pt"-}:{-"\kern-1.1pt"-} X i) {-"\kern-1.1pt"-} → {-"\kern-1.1pt"-} R xs x {-"\kern-1.1pt"-} → {-"\kern-1.1pt"-} S (mapRD (D i) h xs) (h x)
\end{code}
the equivalence on which is pointwise equality on \emph{both} components |h|~and~|c|.
At the beginning of this chapter, we saw in the example about the classifying algebra for the ornament from natural numbers to lists that the relational language is used proof-relevantly, deviating from traditional relational theories; that deviation is fully manifested in this proof-relevant category of relational algebras and homomorphisms.

Before we move on to the natural isomorphisms, it still remains to define |ClsAlg|, in particular the |clsAlg| function.
Considering the completeness theorem, the classifying algebra |clsAlg O| for an ornament |O : Orn e D E| where |E : Desc J| should encode enough information for promoting a given inhabitant of |Ṡ (D (e j))| to one of |Ṡ (E j)| for any |j : J|, so the algebraic ornamentation of~|D| using |clsAlg O| can yield a datatype isomorphic to~|μ E|.
Here for simplicity we require a complete inhabitant of |Ṡ (E j)| that erases to the given inhabitant of |Ṡ (D (e j))| by |erase-Ṡ O (ok j)|:
\begin{code}
clsAlg O : Ḟ D (Inv' e) ↝ Inv' e
clsAlg O js (j , refl) =
  (Σ'(ss ∶ Ṡ (E j)))  erase-Ṡ (O (ok j)) ss ≡
                        proj₁ (Iso.to (horizontal-iso (D (e j)) (Inv' e)) js)
                      × (goal()(3))
\end{code}
Goal~3 is left for talking about the series of recursively computed indices contained in~|js|, which should match with those specified for the recursive positions by |E j|.
(An example is the proof obligation |b' ≡ x| in the classifying algebra for the ornament from lists to ordered lists given at the beginning of this chapter.)
The type of the series of recursively computed indices
\begin{code}
proj₂ (Iso.to (horizontal-iso (D (e j)) (Inv' e)) js)
\end{code}
gets nasty, however; it suffices to know that Goal~3 requires that the above series of indices, when coerced to a |List J|, is equal to |next (E j) ss|.
The morphism part of |ClsAlg| can then be constructed:
\[ \begin{tikzpicture}[x=4em, y=2em, baseline=(P.base), text height=1.5ex, text depth=.25ex]
\node(T)                 {|J , E|};
\node(T') [right=1 of T] {|K , F|};
\node(M) at ($ (T) !.5! (T') $) {};
\node(B)  [below=1 of M] {|I , D|};
\draw[->] (T)  edge node   [left , xshift=-5pt]{|e , O|} (B)
          (T') edge node(P)[right, xshift= 5pt]{|f , P|} (B)
          (T)  edge node[above]{|g , Q|} (T');
\end{tikzpicture}
\quad\mapsto\quad
\begin{tikzpicture}[x=9em, y=2em, baseline=(R.base), text height=1.5ex, text depth=.25ex]
\node(X)                  {|Inv' e|};
\node(Y)   [right=1 of X] {|Inv' f|};
\node(FDX) [below=1 of X] {|Ḟ D (Inv' e)|};
\node(FDY) [below=1 of Y] {|Ḟ D (Inv' f)|};
\draw[->] (FDX) edge node(R)  [left ] {|clsAlg O|}        (X)
          (FDY) edge node     [right] {|clsAlg P|}        (Y)
          (X)   edge node(h)  [above] {|fun (goal()(4))|} (Y)
          (FDX) edge node(RDh)[below] {|Ṙ D (fun _)|}     (FDY);
\node at (R -|| h) {|(goal(⊆)(5))|};
\end{tikzpicture} \]
Goal~4 has type
\begin{code}
{i : I} → ((Σ'(j ∶ J)) e j ≡ i) → (Σ'(k ∶ K)) f k ≡ i
\end{code}
and can be easily discharged by~|g| and the proof |f ∘ g ≐ e| extracted from the commutative triangle.
At Goal~5, we should transform a proof about |clsAlg O| to one about |clsAlg P|; expanding the definition of |clsAlg|, we should transform an inhabitant of |Ṡ (E j)| to one of |Ṡ (F (g j))| for every |j : J|, so |erase-Ṡ (Q (ok j))| does the job, modulo manipulation of the associated equations.
(Here we see clearly that the homomorphism condition can only require the left-to-right direction, since it is the only direction that can be constructed from~|Q|.)

Now we look at the natural isomorphism between |AlgOrn ⋄ ClsAlg| and the identity functor on |Ōrn / (I , D)| --- the construction of the other natural isomorphism between |ClsAlg ⋄ AlgOrn| and the identity functor on |RAlg D| is based on a similar analysis and omitted from the presentation.
The components (indexed by ornaments) of the natural isomorphism were shown in~(\ref{eq:AlgOrn-ClsAlg-inverse}).
Switching to horizontal transformations, we should construct an isomorphism between
\[ |Ṡ (toRDesc (algROD (D (e j)) ((clsAlg O º) (j , refl))))| \qquad\text{and}\qquad |Ṡ (E j)| \]
for each |j : J|, and make sure that its two directions make the corresponding triangles commute.
For the left-to-right direction, by |algROD-iso|, the left-hand side decomposes into some |js : ⟦ D (e j) ⟧ (Inv' e)| and a proof of |clsAlg O js (j , refl)| --- the latter contains an inhabitant of |Ṡ (E j)|, which is exactly what we need.
Conversely, any |ss : Ṡ (E j)| by itself determines a |js : ⟦ D (e j) ⟧ (Inv' e)| and a proof of |clsAlg O js (j , refl)| that contains~|ss|, since the equations in |clsAlg| completely specifies what |js|~should be.
The two directions are inverse to each other because all that is involved is rearrangement of data, and the corresponding triangles commute because (in particular) the fields from~|D| are not modified.
We also need to establish naturality of one of the natural transformations (naturality of the other natural transformation can be derived from the componentwise isomorphisms) --- here we choose the left-to-right direction.
Let |m|~be a morphism in |Ōrn / (I , D)|:
\[ \begin{tikzpicture}[x=4em, y=2em, baseline=(P.base), text height=1.5ex, text depth=.25ex]
\node(T)                 {|J , E|};
\node(T') [right=1 of T] {|K , F|};
\node(M) at ($ (T) !.5! (T') $) {};
\node(B)  [below=1 of M] {|I , D|};
\draw[->] (T)  edge node   [left ,xshift=-4pt,yshift=-2pt]{|e , O|} (B)
          (T') edge node(P)[right,xshift= 4pt,yshift=-2pt]{|f , P|} (B)
          (T)  edge node[above]{|g , Q|} (T');
\end{tikzpicture} \]
Because the equivalence on slice morphisms ignores the commutative triangles, we only need to establish commutativity of the following square in |Ōrn|:
\[ \begin{tikzpicture}[x=3em, y=3em, baseline=(P.base), text height=1.5ex, text depth=.25ex]
\node(FX)                 {|Σ I (Inv' e) , ⌊ algOD D (clsAlg O) ⌋|};
\node(X)  [right=1 of FX] {|J , E|};
\node(FY) [below=1 of FX] {|Σ I (Inv' f) , ⌊ algOD D (clsAlg P) ⌋|};
\node(Y)  [below=1 of X ] {|K , F|};
\draw[->] (FX) edge node[above]{|φ O|} (X)
          (FY) edge node(P)[below]{|φ P|} (Y)
          (FX) edge node[left ]{|morphism (SliceF ⋄ AlgOrn ⋄ ClsAlg) m|} (FY)
          (X)  edge node[right]{|g , Q|} (Y);
\end{tikzpicture} \]
where |φ|~denotes the components of the natural transformation sketched above.
Switching to |ḞHTrans|, the vertical morphisms essentially replace a shape of type |Ṡ (E j)| (for some suitable |j : J|) with one of type |Ṡ (F (g j))|, while the horizontal ones extract those shapes.
The two operations are independent, and hence the diagram commutes.

\section{Consequences}
\label{sec:equivalence-consequences}

We began this chapter with the completeness theorem, and, with some effort, have extended it to a categorical equivalence.
The extra effort is not wasted: the categorical equivalence allows us to perform reasoning across the realms of ornaments and relational algebras easily.
Below we give two examples that connect ornamental and relational algebraic constructions via the categorical equivalence.

\subsection{Ornamental algebraic ornamentation}
\label{sec:OAO}

The idea of computing promotion predicates and conversion isomorphisms from ornaments was first fully formulated by \citet{Ko-OAOAOO}, where the promotion predicates were computed by ``ornamental algebraic ornamentation'', i.e., algebraic ornamentation with an ornamental algebra.
This dissertation, on the other hand, uses parallel composition with singleton ornamentation to compute (optimised) ornamental promotion predicates.
Using a part of the categorical equivalence, we can show that the two approaches indeed yield isomorphic predicates.

Let |O : Orn e D E| where |D : Desc I| and |E : Desc J|.
Our goal is to show that the datatype obtained by algebraic ornamentation of~|E| with the ornamental algebra
\begin{code}
fun (ornAlg O) : Ḟ E (μ D ∘ e) ↝ (μ D ∘ e)
\end{code}
is isomorphic to the optimised predicate datatype for~|O|, i.e.,
\begin{code}
Iso Fam  (Σ J (μ D ∘ e)  , μ ⌊ algOD E (fun (ornAlg O)) ⌋)
         (e ⋈ proj₁      , μ ⌊ O ⊗ ⌈ S ⌉ ⌋)
\end{code}
where |S = singletonOD D|.
By isomorphism preservation of |Ind|, it suffices to establish
\begin{code}
Iso Ōrn  (Σ J (μ D ∘ e)  , ⌊ algOD E (fun (ornAlg O)) ⌋)
         (e ⋈ proj₁      , ⌊ O ⊗ ⌈ S ⌉ ⌋)
\end{code}
We are attempting to establish that an algebraic ornamentation of~|E| is isomorphic to some other description; if that description is also an algebraic ornamentation of~|E|, then we can just reason in terms of their algebras.
This is easy: from any ornament |P : Orn f E ⌊ O ⊗ ⌈ S ⌉ ⌋| we get an isomorphism 
\begin{code}
Iso Ōrn  (e ⋈ proj₁     , ⌊ O ⊗ ⌈ S ⌉ ⌋)
         (Σ J (Inv' f)  , ⌊ algOD E (clsAlg P) ⌋)
\end{code}
and there is an obvious choice of~|P| --- |diffOrn-l O ⌈ S ⌉|.
The proof obligation thus reduces to
\begin{code}
Iso Ōrn  (Σ J (μ D ∘ e)  , ⌊ algOD E (fun (ornAlg O)) ⌋)
         (Σ J (Inv' π₁)  , ⌊ algOD E (clsAlg (diffOrn-l O ⌈ S ⌉)) ⌋)
\end{code}
which, by isomorphism preservation of |SliceF ⋄ AlgOrn|, is further reduced to
\begin{code}
Iso (RAlg E)  (μ D ∘ e  , fun (ornAlg O))
              (Inv' π₁  , clsAlg (diffOrn-l O ⌈ S ⌉))
\end{code}
This is a proof obligation that we can discharge more easily.
For the carriers, we need to show
\begin{code}
μ D (e j) ≅ (Σ'(p ∶ e ⋈ proj₁)) π₁ p ≡ j
\end{code}
for every |j : J|, which is easy since the canonical form of~|p| is |(ok j , ok (e j , d))| for some |d : μ D (e j)|.
For the algebras,

\begin{code}

\end{code}

\subsection{Parallel composition and the banana-split law}
\label{sec:banana-split}

\todo[inline]{algebras corresponding to singleton ornaments and ornaments for optimised predicates}

\section{Discussion}
\label{sec:equivalence-discussion}

\todo[inline]{implicit change from |Inv| to |Inv'|; (bad computational behaviour;) ornaments for optimised representation; compare the \citet{McBride-ornaments} version (compatible with the two-constructor universe) and the \citet{Dagand-functional-ornaments} version of algebraic ornamentation in terms of ``quality'' (amount of~|σ|'s used); proof-relevant Algebra of Programming (e.g., |fun-preserves-fold|)}

Starting from \autoref{chap:categorical}, we have been carefully evading the formalisation of isomorphism of categories.

Perhaps the most important consequence of the completeness theorem (in its present form) is that it provides a new perspective on the expressive power of ornaments and inductive families.
We showed in a previous paper~\cite{Ko-pcOrn} that every ornament induces a promotion predicate and a corresponding family of isomorphisms.
But one question was untouched: can we determine (independently from ornaments) the range of predicates induced by ornaments?
An answer to this question would tell us something about the expressive power of ornaments, and also about the expressive power of inductive families in general, since the inductive families we use are usually ornamentations of simpler algebraic datatypes from traditional functional programming.
The completeness theorem offers such an answer: ornament-induced promotion predicates are exactly those expressible as relational folds (up to pointwise isomorphism).
In other words, a predicate can be baked into a datatype by ornamentation if and only if it can be thought of as a nondeterministic classification of the inhabitants of the datatype with a relational fold.
This is more a guideline than a precise criterion, though, as the closest work about characterisation of the expressive power of folds discusses only functional folds~\cite{Gibbons-kernels}
(however, we believe that those results generalise to relations too).
But this does encourage us to think about ornamentation computationally and to design new datatypes with relational algebraic methods.
